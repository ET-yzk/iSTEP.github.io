<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Django-session</title>
    <url>/iSTEP.github.io/2021/08/01/Django-session/</url>
    <content><![CDATA[<p>cookie: Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的键值对数据</p>
<p>HTTP 协议是<strong>无状态</strong>的。所以服务器无法根据 HTTP 协议来辨别多个 HTTP 请求来自哪个用户。在实际场景中，服务器经常需要追踪客户端的状态。为了解决这个问题， Cookie 技术应运而生。</p>
<p>cookie 一开始是服务器产生的一段随机字符串。它的主要内容包括：名字，值，过期时间，路径与域等信息。然后服务器将其发送给客户端。在后续的请求中，cookie 会附在请求资源的 HTTP 请求头上，发送给服务器。</p>
<h2 id="1-什么是session？"><a href="#1-什么是session？" class="headerlink" title="1.什么是session？"></a>1.什么是session？</h2><hr>
<p>首先引入百度百科的解释：Session:在计算机网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。Session 对象最常见的一个用法就是存储用户的首选项。例如，如果用户指明不喜欢查看图形，就可以将该信息存储在 Session 对象中。有关使用 Session 对象的详细信息，请参阅“ASP 应用程序”部分的“管理会话”。注意 会话状态仅在支持 cookie 的浏览器中保留。</p>
<p>我的理解: 服务器端为了保存某些数据，或实现某些必要的功能，当用户访问服务器时，将数据临时保存在服务器端以供完成服务器端的其他某些功能。服务器需要保存的数据可以以cookie的方式存储在客户端，而session的功能就是将服务器需要保存的数据存储在服务端。例如账号登录记录的功能，可以以session的方式将登录状态保存在服务器端，这样当用户访问其他程序时，需要用到登录的地方，都可以从该用户的session中取出该用户的数据，为用户服务。</p>
<h2 id="2-session和cookie的区别"><a href="#2-session和cookie的区别" class="headerlink" title="2.session和cookie的区别"></a>2.session和cookie的区别</h2><hr>
<p>session的底层是基于cookie技术来实现的，在早期保存会话状态一直用的cookie，cookie是保存在客户端的明文键值对，但这样直接保存重要信息是不安全的，后来衍生了session，session是加密后的cookie键值，加密后的值即使被人截取，也无法获取到密码等敏感信息，避免了重要资源信息泄露。当用户打开浏览器，去访问服务器的时候，服务器会为每个用户的浏览器创建一个会话对象(session对象)，并且为每个session对象创建一个session_id。当session对象创建成功后，会以cookie的方式将这个session_id回写给浏览器，当用户再次进行访问服务器时，及带了具有session_id的cookie数据来一起访问服务器，服务器通过不同session的 session_id来找出与其相关联的session对象，通过不同的session对象来为不同的用户服务。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yzketx/image-markdown/raw/master/img/1389184-20180528135915678-1257197184.png"
                      alt="img"
                ></p>
<h2 id="3-在Django中session的使用方法-示例"><a href="#3-在Django中session的使用方法-示例" class="headerlink" title="3.在Django中session的使用方法-示例"></a>3.在Django中session的使用方法-示例</h2><hr>
<p>Django中默认支持Session，其内部提供了5种类型的Session供开发者使用：</p>
<p><strong>·</strong> 数据库（默认）<br>        <strong>·</strong> 缓存<br>        **· **文件<br>        <strong>·</strong> 缓存+数据库<br>        **· **加密cookie</p>
<p>（1）数据库中的Session</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Django默认支持Session，并且默认是将Session数据存储在数据库中，即：django_session 表中。</span><br><span class="line"></span><br><span class="line">a. 配置 settings.py</span><br><span class="line"></span><br><span class="line">    SESSION_ENGINE = <span class="string">&#x27;django.contrib.sessions.backends.db&#x27;</span>   <span class="comment"># 引擎（默认）</span></span><br><span class="line"></span><br><span class="line">    SESSION_COOKIE_NAME ＝ <span class="string">&quot;sessionid&quot;</span></span><br><span class="line">    <span class="comment"># Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）</span></span><br><span class="line">    SESSION_COOKIE_PATH ＝ <span class="string">&quot;/&quot;</span></span><br><span class="line">    <span class="comment"># Session的cookie保存的路径（默认）</span></span><br><span class="line">    SESSION_COOKIE_DOMAIN = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># Session的cookie保存的域名（默认）</span></span><br><span class="line">    SESSION_COOKIE_SECURE = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 是否Https传输cookie（默认）</span></span><br><span class="line">    SESSION_COOKIE_HTTPONLY = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 是否Session的cookie只支持http传输（默认）</span></span><br><span class="line">    SESSION_COOKIE_AGE = <span class="number">1209600</span></span><br><span class="line">    <span class="comment"># Session的cookie失效日期（2周）（默认）</span></span><br><span class="line">    SESSION_EXPIRE_AT_BROWSER_CLOSE = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 是否关闭浏览器使得Session过期（默认）</span></span><br><span class="line">    SESSION_SAVE_EVERY_REQUEST = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 是否每次请求都保存Session，默认修改之后才保存（默认）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b. 使用</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">        <span class="comment"># 获取、设置、删除Session中数据</span></span><br><span class="line">        request.session[<span class="string">&#x27;k1&#x27;</span>]</span><br><span class="line">        request.session.get(<span class="string">&#x27;k1&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">        request.session[<span class="string">&#x27;k1&#x27;</span>] = <span class="number">123</span></span><br><span class="line">        request.session.setdefault(<span class="string">&#x27;k1&#x27;</span>,<span class="number">123</span>) <span class="comment"># 存在则不设置</span></span><br><span class="line">        <span class="keyword">del</span> request.session[<span class="string">&#x27;k1&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 所有 键、值、键值对</span></span><br><span class="line">        request.session.keys()</span><br><span class="line">        request.session.values()</span><br><span class="line">        request.session.items()</span><br><span class="line">        request.session.iterkeys()</span><br><span class="line">        request.session.itervalues()</span><br><span class="line">        request.session.iteritems()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用户session的随机字符串</span></span><br><span class="line">        request.session.session_key</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 将所有Session失效日期小于当前日期的数据删除</span></span><br><span class="line">        request.session.clear_expired()</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 检查 用户session的随机字符串 在数据库中是否</span></span><br><span class="line">        request.session.exists(<span class="string">&quot;session_key&quot;</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 删除当前用户的所有Session数据</span></span><br><span class="line">        request.session.delete(<span class="string">&quot;session_key&quot;</span>)</span><br><span class="line">        request.session.clear()</span><br><span class="line"> </span><br><span class="line">        request.session.set_expiry(value)</span><br><span class="line">            * 如果value是个整数，session会在些秒数后失效。</span><br><span class="line">            * 如果value是个datatime或timedelta，session就会在这个时间后失效。</span><br><span class="line">            * 如果value是<span class="number">0</span>,用户关闭浏览器session就会失效。</span><br><span class="line">            * 如果value是<span class="literal">None</span>,session会依赖全局session失效策略。</span><br></pre></td></tr></table></figure>

<p>（2）缓存Session</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a. 配置 settings.py</span><br><span class="line"> </span><br><span class="line">    SESSION_ENGINE = <span class="string">&#x27;django.contrib.sessions.backends.cache&#x27;</span>  <span class="comment"># 引擎</span></span><br><span class="line">    SESSION_CACHE_ALIAS = <span class="string">&#x27;default&#x27;</span></span><br><span class="line">    <span class="comment"># 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置</span></span><br><span class="line"></span><br><span class="line">    SESSION_COOKIE_NAME ＝ <span class="string">&quot;sessionid&quot;</span></span><br><span class="line">    <span class="comment"># Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串</span></span><br><span class="line">    SESSION_COOKIE_PATH ＝ <span class="string">&quot;/&quot;</span></span><br><span class="line">    <span class="comment"># Session的cookie保存的路径</span></span><br><span class="line">    SESSION_COOKIE_DOMAIN = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># Session的cookie保存的域名</span></span><br><span class="line">    SESSION_COOKIE_SECURE = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 是否Https传输cookie</span></span><br><span class="line">    SESSION_COOKIE_HTTPONLY = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 是否Session的cookie只支持http传输</span></span><br><span class="line">    SESSION_COOKIE_AGE = <span class="number">1209600</span></span><br><span class="line">    <span class="comment"># Session的cookie失效日期（2周）</span></span><br><span class="line">    SESSION_EXPIRE_AT_BROWSER_CLOSE = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 是否关闭浏览器使得Session过期</span></span><br><span class="line">    SESSION_SAVE_EVERY_REQUEST = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 是否每次请求都保存Session，默认修改之后才保存</span></span><br><span class="line"> </span><br><span class="line">b. 使用 同上</span><br></pre></td></tr></table></figure>

<p>（3）文件Session</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a. 配置 settings.py</span><br><span class="line"> </span><br><span class="line">    SESSION_ENGINE = <span class="string">&#x27;django.contrib.sessions.backends.file&#x27;</span>    <span class="comment"># 引擎</span></span><br><span class="line">    SESSION_FILE_PATH = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir()</span></span><br><span class="line">    <span class="comment"># 如：/var/folders/d3/j9tj0gz93dg06bmwxmhh6_xm0000gn/T</span></span><br><span class="line"></span><br><span class="line">    SESSION_COOKIE_NAME ＝ <span class="string">&quot;sessionid&quot;</span></span><br><span class="line">    <span class="comment"># Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串</span></span><br><span class="line">    SESSION_COOKIE_PATH ＝ <span class="string">&quot;/&quot;</span>                                  <span class="comment"># Session的cookie保存的路径</span></span><br><span class="line">    SESSION_COOKIE_DOMAIN = <span class="literal">None</span>                                <span class="comment"># Session的cookie保存的域名</span></span><br><span class="line">    SESSION_COOKIE_SECURE = <span class="literal">False</span>                               <span class="comment"># 是否Https传输cookie</span></span><br><span class="line">    SESSION_COOKIE_HTTPONLY = <span class="literal">True</span>                              <span class="comment"># 是否Session的cookie只支持http传输</span></span><br><span class="line">    SESSION_COOKIE_AGE = <span class="number">1209600</span>                                <span class="comment"># Session的cookie失效日期（2周）</span></span><br><span class="line">    SESSION_EXPIRE_AT_BROWSER_CLOSE = <span class="literal">False</span>                     <span class="comment"># 是否关闭浏览器使得Session过期</span></span><br><span class="line">    SESSION_SAVE_EVERY_REQUEST = <span class="literal">False</span>                          <span class="comment"># 是否每次请求都保存Session，默认修改之后才保存</span></span><br><span class="line"> </span><br><span class="line">b. 使用 同上</span><br></pre></td></tr></table></figure>

<p>（4）缓存+数据库Session</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">数据库用于做持久化，缓存用于提高效率</span><br><span class="line"> </span><br><span class="line">a. 配置 settings.py</span><br><span class="line">	SESSION_ENGINE = <span class="string">&#x27;django.contrib.sessions.backends.cached_db&#x27;</span>        <span class="comment"># 引擎</span></span><br><span class="line"> </span><br><span class="line">b. 使用 同上</span><br></pre></td></tr></table></figure>

<p>（5）加密Session</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a. 配置 settings.py</span><br><span class="line">	SESSION_ENGINE = <span class="string">&#x27;django.contrib.sessions.backends.signed_cookies&#x27;</span>  <span class="comment"># 引擎</span></span><br><span class="line"> </span><br><span class="line">b. 使用 同上</span><br></pre></td></tr></table></figure>

<p>（6）Session的用户验证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span>(<span class="params">request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 如果未登陆，跳转到指定页面</span></span><br><span class="line">        <span class="keyword">if</span> request.path == <span class="string">&#x27;/test/&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(request, *args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br></pre></td></tr></table></figure>

<p> 利用session做个用户认证示例：</p>
<p><em><strong>Views.py</strong></em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,redirect,HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method==<span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> request.method==<span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        user=request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        pwd=request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> user==<span class="string">&quot;root&quot;</span> <span class="keyword">and</span> pwd==<span class="string">&quot;123&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> request.POST.get(<span class="string">&#x27;box&#x27;</span>)==<span class="string">&quot;1&quot;</span>:   <span class="comment">#checkbox被按下</span></span><br><span class="line">                request.session.set_expiry(<span class="number">10</span>)  <span class="comment">#session认证时间为10s，10s之后session认证失效</span></span><br><span class="line">            request.session[<span class="string">&#x27;username&#x27;</span>]=user   <span class="comment">#user的值发送给session里的username</span></span><br><span class="line">            request.session[<span class="string">&#x27;is_login&#x27;</span>]=<span class="literal">True</span>   <span class="comment">#认证为真</span></span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;/index&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.session.get(<span class="string">&#x27;is_login&#x27;</span>,<span class="literal">None</span>):  <span class="comment">#若session认证为真</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>,&#123;<span class="string">&#x27;username&#x27;</span>:request.session[<span class="string">&#x27;username&#x27;</span>]&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;认证失败&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span>(<span class="params">request</span>):</span>                 <span class="comment">#撤销</span></span><br><span class="line">    request.session.clear()         <span class="comment">#删除session里的全部内容</span></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/login&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><em><strong>login.html</strong></em></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/static/js/jquery-1.12.4.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/static/js/jquery.cookie.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----------CSRF_TOKEN通过form表单发送到后台进行验证----------&gt;</span></span><br><span class="line">        &#123;% csrf_token %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;box&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span> 10s超时</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btu-1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Ajax-1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            $.ajaxSetup(&#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">beforeSend</span>:<span class="function"><span class="keyword">function</span> (<span class="params">xhr,settings</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    xhr.setRequestHeader(<span class="string">&#x27;X-CSRFtoken&#x27;</span>,$.cookie(<span class="string">&#x27;csrftoken&#x27;</span>))</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&#x27;#btu-1&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">url</span>:<span class="string">&quot;/login/&quot;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">data</span>:&#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&quot;root&quot;</span>,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;123&quot;</span>&#125;,</span></span><br><span class="line"><span class="javascript">                &#125;)</span></span><br><span class="line"><span class="javascript">            &#125;)</span></span><br><span class="line"><span class="javascript">        &#125;)()</span></span><br></pre></td></tr></table></figure>

<p><em><strong>index.html</strong></em></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span>    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎登录：&#123;&#123; username &#125;&#125;,&#123;&#123; request.session.username &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://127.0.0.1:8006/logout/&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注销&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/iSTEP.github.io/2021/08/01/Docker/</url>
    <content><![CDATA[<h2 id="Hello-Docker"><a href="#Hello-Docker" class="headerlink" title="Hello Docker"></a>Hello Docker</h2><p><code>Docker</code>是一款轻量级虚拟化容器的管理引擎。</p>
<h5 id="Docker的两个基本概念"><a href="#Docker的两个基本概念" class="headerlink" title="Docker的两个基本概念"></a>Docker的两个基本概念</h5><p>关于<code>Docker</code>容器，涉及到两个非常重要的概念：镜像和容器。</p>
<h6 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h6><p><code>镜像</code>可以理解为一个打包了运行环境的特殊文件系统，它包含了容器启动运行所需的所有信息，包括运行程序和配置数据等。镜像不包含任何动态数据，其内容在构建之后也不会改变。</p>
<p>例如，一个官方的<code>Ubuntu20.04</code>镜像，就包含了一套完整的<code>Ubuntu20.04</code>最小系统的<code>root</code>文件系统。</p>
<h6 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h6><p><code>镜像</code>和<code>容器</code>的关系，类似于面向对象程序设计中的<code>类</code>和<code>实例</code>一样，<code>镜像</code>是静态的定义，而<code>容器</code>是镜像运行时的实体，可以看成是一个具备某个运行环境的非常轻量的虚拟机。<code>容器</code>可以被创建、启动、停止和删除等。在创建容器时，需要显示地为容器指定镜像。指定镜像之后，容器就具备了镜像中保存的运行环境了。</p>
<p>例如，可以为容器指定<code>Ubuntu20.04</code>的镜像，然后该容器就具备<code>Ubuntu20.04</code>的运行环境了。</p>
<h5 id="Docker使用的基本过程"><a href="#Docker使用的基本过程" class="headerlink" title="Docker使用的基本过程"></a>Docker使用的基本过程</h5><p>容器需要基于一个镜像来创建和使用。因此，<code>Docker</code>容器的使用一般有以下三个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取一个镜像；基于该镜像创建并启动一个容器；进入该容器，执行“程序”。</span><br></pre></td></tr></table></figure>

<ul>
<li>第一步：获取镜像； 上面我们提到了“镜像”可以理解为一个打包了运行环境的文件系统。然而在安装完<code>Docker</code>服务之后，本地是没有任何镜像的，所以首先需要获取所需要的镜像。</li>
<li>第二步：创建并启动容器； 在获取到所需的镜像之后，就可以基于该镜像创建并启动一个容器，该容器就具备了镜像包含的运行环境了。同时，在创建容器时也可以设置容器的启动命令，该命令会在容器启动时执行。</li>
<li>第三步：进入容器并执行程序； 在容器成功创建并启动之后，该容器就具备了<code>ubuntu</code>的运行环境。我们可以进入该容器内部，并在其内部执行任何在<code>ubuntu</code>系统上的程序了。这里的“程序”可以是“<code>Linux</code>命令”、“<code>shell</code>脚本”、“<code>C++</code>程序”等。</li>
</ul>
<p>在本实训的后续关卡，我们将具体而详实的介绍上述各个步骤的命令和后台处理过程。本关主要以一个<code>启动容器并在容器内控制台中输出“Hello Docker”</code>基本案例来介绍这个过程。</p>
<h5 id="Docker使用基本实例"><a href="#Docker使用基本实例" class="headerlink" title="Docker使用基本实例"></a>Docker使用基本实例</h5><p>本关通过一个<code>启动容器并在容器内控制台中输出“Hello Docker”</code>的基本使用案例粗略介绍<code>Docker</code>的使用及后台处理过程，帮助大家理解<code>Docker</code>的运行机制。</p>
<p>启动一个容器并输出“<code>Hello Docker</code>”的基本语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull busybox:latestdocker run --name first_docker_container busybox:latest echo &quot;Hello Docker&quot;</span><br></pre></td></tr></table></figure>

<p>没错，只需要两条命令，就可以完成了在容器中输出“<code>Hello Docker</code>”了，很简单吧！现在我们来介绍一下这两条命令在后台做了什么工作。</p>
<ul>
<li>第一条命令：获取一个名为<code>busybox:latest</code>的镜像。这条命令会从<code>Docker Hub</code>官方镜像仓库获取一个名为<code>busybox:latest</code>的镜像(<code>busybox</code>的最新版)，并把它下载到宿主机。其中<code>busybox</code>是最小的<code>Linux</code>系统。</li>
<li>第二条命令： 创建并启动一个容器，并执行相应命令。首先，<code>--name</code>设置容器的名字为<code>first_docker_container</code>，然后为容器指定了<code>busybox:latest</code>作为启动镜像，最后设置了该容器的启动命令为<code>echo &quot;Hello Docker&quot;</code>。容器启动并输出 “<code>Hello Docker</code>”后，将其停止。</li>
</ul>
<p>在这个实例中，我们并不需要进入容器执行“程序”，因为我们设置了容器的启动命令，也就是<code>echo &quot;Hello Docker&quot;</code>。上面我们说过，在容器启动时会在容器中执行“启动命令”，执行完<code>echo &quot;Hello Docker&quot;</code>，输出了“<code>Hello Docker</code>”，已经达到了我们的要求，所以就无需进入容器内部执行了。(后面会具体的介绍如何在容器内部执行“程序”！！)</p>
<p>其实我们也可以去掉第一条命令，直接使用第二条命令即可完成同样的功能。后台在执行命令时，发现本地没有<code>busybox:latest</code>镜像，会首先自动执行<code>docker pull busybox:latest</code>，将<code>busybox:latest</code>镜像下载到宿主机，然后再以<code>busybox</code>镜像作为基础，创建一个名为<code>first_docker_container</code>的镜像，并执行<code>echo “Hello Docker”</code>命令。</p>
]]></content>
  </entry>
  <entry>
    <title>Environment</title>
    <url>/iSTEP.github.io/2021/08/01/Environment/</url>
    <content><![CDATA[<h2 id="推荐环境"><a href="#推荐环境" class="headerlink" title="推荐环境"></a>推荐环境</h2><ul>
<li>OJBackend: Pycharm Profession 最新版</li>
<li>OJFE: Webstorm 最新版</li>
</ul>
<h2 id="申请-JetBrains-学生认证"><a href="#申请-JetBrains-学生认证" class="headerlink" title="申请 JetBrains 学生认证"></a>申请 JetBrains 学生认证</h2><ol>
<li><p>打开 <a class="link"   href="https://www.jetbrains.com/shop/eform/students" >JetBrains学生申请链接<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>依次填入你的信息<br>注意！！邮箱必须是学校账号，如 <a class="link"   href="http://mail.zjgsu.edu.cn/" >浙江工商大学邮箱<i class="fas fa-external-link-alt"></i></a> <strong>学号@pop.zjgsu.edu.cn</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yzketx/image-markdown/raw/master/img/jetbrains%E5%AD%A6%E7%94%9F%E7%94%B3%E8%AF%B7.png"
                      alt="image-20210713124733657"
                ></p>
</li>
<li><p>前往邮箱验证邮件<br>接下来前往学校的邮箱系统验证邮件，如果进去发现收件箱里没有邮件，可能因为被拦截了，因此要到拦截队列里去找。<br>验证成功之后如下<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img-blog.csdnimg.cn/20200302144057720.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjU2ODc5,size_16,color_FFFFFF,t_70"
                      alt="在这里插入图片描述"
                ></p>
</li>
<li><p>确认信件信息并注册jetbrians账号<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yzketx/image-markdown/raw/master/img/1343525-20180403165217221-912419064.png"
                      alt="img"
                ></p>
<p>然后jetbrians提示已经成功，并发信件给你</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yzketx/image-markdown/raw/master/img/1343525-20180403165248908-561819286.png"
                      alt="img"
                > 打开链接，会出现注册页面，填入你的用户名，密码就注册成功，最后跳转至个人主页<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yzketx/image-markdown/raw/master/img/image-20210713130319829.png"
                      alt="image-20210713130319829"
                ><br>最后使用你注册的账号登陆就可以使用了。</p>
</li>
<li><p>在JetBrains产品中登录或填写提供的 License ID即可激活使用。</p>
</li>
<li><p>账号权限续期</p>
<p>学生认证权限一年需要续订一次（毕业后失效），在次年即将到期时，JetBrains将会发送邮件询问是否续订，根据邮件内链接操作即可完成续订。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Issue</title>
    <url>/iSTEP.github.io/2021/08/01/Issue/</url>
    <content><![CDATA[<h2 id="backend"><a href="#backend" class="headerlink" title="backend"></a>backend</h2><p><code>docker 可通过 【docker logs name --tail 行数】来查看服务的日志</code></p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="1-前端页面显示正常，登入用户时报-“server-error”"><a href="#1-前端页面显示正常，登入用户时报-“server-error”" class="headerlink" title="1. 前端页面显示正常，登入用户时报 “server error”"></a>1. 前端页面显示正常，登入用户时报 “server error”</h4><p><strong>错误分析</strong></p>
<ul>
<li>通过本地后端调试发现报错：MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error.</li>
<li>该错误表示Redis被配置为保存数据库快照，但它目前不能持久化到硬盘。用来修改集合数据的命令不能用。</li>
<li>Redis因为强制重启或宿主机内存不足导致快照未能从内存完整保存至本地，最终造成持久化失败，Redis拒绝写入新数据。</li>
<li>由于登入请求记录无法提交至Redis数据库，导致用户登入失败。</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li>bgsave: 进行当前数据的异步保存</li>
<li>save: 进行当前数据的保存，会阻塞当前请求</li>
<li>如果当前数据丢失，似乎会影响竞赛排名页的更新</li>
</ul>
<ol>
<li><p>【<strong>推荐</strong>】在/etc/sysctl.conf 添加一项 ‘vm.overcommit_memory = 1’ ，然后运行命令’sysctl vm.overcommit_memory=1’（或者重启）使其生效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内存不足：简单说，Redis在保存数据到硬盘时为了避免主进程假死，需要Fork一份主进程，然后在Fork进程内完成数据保存到硬盘的操作，如果主进程使用了4GB的内存，Fork子进程的时候需要额外的4GB，此时内存就不够了，Fork失败，进而数据保存硬盘也失败了。</span><br><span class="line"></span><br><span class="line">而将vm.overcommit_memory改为1有什么作用呢，网上看到一个博客是如下解释：</span><br><span class="line"></span><br><span class="line">0 — 默认设置,当应用进程尝试申请内存时，内核会做一个检测。内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。举个例子，比如1G的机器，A进程已经使用了500M，当有另外进程尝试malloc 500M的内存时，内核就会进行check，发现超出剩余可用内存，就会提示失败。</span><br><span class="line"></span><br><span class="line">1 — 对于内存的申请请求，内核不会做任何check，直到物理内存用完，触发OOM杀用户态进程。同样是上面的例子，1G的机器，A进程500M，B进程尝试malloc 500M，会成功，但是一旦kernel发现内存使用率接近1个G(内核有策略)，就触发OOM，杀掉一些用户态的进程(有策略的杀)。</span><br><span class="line"></span><br><span class="line">2 — 当请求申请的内存 &gt;= SWAP内存大小 + 物理内存 * N，则拒绝此次内存申请。解释下这个N：N是一个百分比，根据overcommit_ratio/100来确定，比如overcommit_ratio=50，那么N就是50%。</span><br></pre></td></tr></table></figure></li>
<li><p>【<strong>推荐与1一起使用</strong>】通过redis-cli连接Redis数据库，将stop-writes-on-bgsave-error设置为no，如下。该方法在  <strong>因内存不足时造成错误</strong>  无法从根源解决问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config <span class="built_in">set</span> stop-writes-on-bgsave-error no</span><br></pre></td></tr></table></figure></li>
<li><p>【<strong>不推荐</strong>】重启Redis可以临时解决，但很快就会再次报错。</p>
</li>
</ol>
<h4 id="1-1-前端直接连不上后端，Redis设置config-set-stop-writes-on-bgsave-error-no临时解决"><a href="#1-1-前端直接连不上后端，Redis设置config-set-stop-writes-on-bgsave-error-no临时解决" class="headerlink" title="1.1 前端直接连不上后端，Redis设置config set stop-writes-on-bgsave-error no临时解决"></a>1.1 前端直接连不上后端，Redis设置config set stop-writes-on-bgsave-error no临时解决</h4><p>   <strong>Redis报错</strong> </p>
<ul>
<li>!! Failed opening the RDB file root (in server root dir <em><strong>/etc/crontabs</strong></em>) for saving: Permission denied</li>
</ul>
<p>   <strong>问题分析</strong></p>
<p>   通过 <code>config get dir</code> 发现Redis的数据保存位置被篡改为 <code>/etc/crontabs</code> ，该位置为只读文件系统，Redis的操作为不安全操作，没有写入权限，导致保存失败。</p>
<p>   <strong>解决方案</strong></p>
<ol>
<li><p>通过 <code>config set dir</code> 将目录改回原始存储路径即可解决。</p>
</li>
<li><p>为Redis设置密码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">config <span class="keyword">get</span> requirepass  # 查看现有的redis密码</span><br><span class="line"></span><br><span class="line">config <span class="keyword">set</span> requirepass <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>  #（<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>为你要设置的密码）设置redis密码</span><br><span class="line"></span><br><span class="line">#  若出现(error) NOAUTH Authentication required.错误，说明已设置密码，使用 auth 密码 来认证密码</span><br></pre></td></tr></table></figure></li>
<li><p>由于该 Redis 基于 docker 构建，重启后将恢复默认设置！！</p>
<blockquote>
<p>另  Django 的 app/oj/setting.py文件需做如下修改</p>
</blockquote>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yzketx/image-markdown/raw/master/img/image-20210728205741096.png"
                      alt="image-20210728205741096" style="zoom:10%;" 
                >！！该方法可以实现登入，但在提交问题时会出错</p>
</blockquote>
<blockquote>
<p> 正确方法如下:</p>
</blockquote>
<blockquote>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yzketx/image-markdown/raw/master/img/image-20210730141913322.png"
                      style="zoom:50%;" 
                >  oj/dev_settings.py: 用于调试环境的配置</p>
</blockquote>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yzketx/image-markdown/raw/master/img/image-20210730142131016.png"
                      alt="image-20210730142131016" style="zoom:50%;" 
                >  oj/production_settings.py: 用于生产环境的配置</p>
</blockquote>
<blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yzketx/image-markdown/raw/master/img/image-20210730142655656.png"
                      alt="image-20210730142655656" style="zoom:50%;" 
                >  oj/settings.py: Django 配置 Redis</p>
</blockquote>
<blockquote>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yzketx/image-markdown/raw/master/img/image-20210730143136700.png"
                      alt="image-20210730143136700" style="zoom:50%;" 
                >  docker-compose.yml: 在环境变量中添加 Redis 密码</p>
</blockquote>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d  <span class="comment"># 使 docker-compose.yml 生效【Recreating Done 的 image 无需执行下步】</span></span><br><span class="line">docker restart istep-backend  <span class="comment"># 使修改的 .py 文件生效</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<p><em><strong>TODO</strong></em></p>
<ol>
<li>构建本地 redis.config 文件，使配置永久生效【数据存储位置挂载，设置密码】</li>
<li>在构建容器时预设定 Redis 密码</li>
</ol>
<h4 id="2-警告：WARNING-you-have-Transparent-Huge-Pages-THP-support-enabled-in-your-kernel-This-will-create-latency-and-memory-usage-issues-with-Redis-To-fix-this-issue-run-the-command-‘echo-never-gt-sys-kernel-mm-transparent-hugepage-enabled’-as-root-and-add-it-to-your-etc-rc-local-in-order-to-retain-the-setting-after-a-reboot-Redis-must-be-restarted-after-THP-is-disabled"><a href="#2-警告：WARNING-you-have-Transparent-Huge-Pages-THP-support-enabled-in-your-kernel-This-will-create-latency-and-memory-usage-issues-with-Redis-To-fix-this-issue-run-the-command-‘echo-never-gt-sys-kernel-mm-transparent-hugepage-enabled’-as-root-and-add-it-to-your-etc-rc-local-in-order-to-retain-the-setting-after-a-reboot-Redis-must-be-restarted-after-THP-is-disabled" class="headerlink" title="2. 警告：WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command ‘echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled’ as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled."></a>2. 警告：WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command ‘echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled’ as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</h4><p>说明：Redis建议我们关闭THP，以免造成相关问题</p>
<p>解决警告中已给出</p>
<hr>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="smtp-配置不成功"><a href="#smtp-配置不成功" class="headerlink" title="smtp 配置不成功"></a>smtp 配置不成功</h3><ul>
<li>OnlineJudge 不支持 ssl，请使用 tls，比如 qq 邮箱是 smtp.qq.com / tls / port 25</li>
<li>部分邮箱 smtp 密码不是登录密码，而是单独的授权密码</li>
</ul>
<h3 id="忘记用户密码"><a href="#忘记用户密码" class="headerlink" title="忘记用户密码"></a>忘记用户密码</h3><ul>
<li>网页上找回密码</li>
<li>后台用户管理重置</li>
<li>超级管理员等密码也忘记，可以使用下面的命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it oj-backend /bin/sh</span><br><span class="line">python3 manage.py inituser --username USERNAME --password NEW_PASSWORD --action=reset</span><br></pre></td></tr></table></figure>

<h3 id="CentOS-上部署遇到问题"><a href="#CentOS-上部署遇到问题" class="headerlink" title="CentOS 上部署遇到问题"></a>CentOS 上部署遇到问题</h3><ul>
<li><p>检查 docker 版本是否太老</p>
</li>
<li><p>关闭 SELinux</p>
</li>
</ul>
<h3 id="查看-Docker-容器运行状态"><a href="#查看-Docker-容器运行状态" class="headerlink" title="查看 Docker 容器运行状态"></a>查看 Docker 容器运行状态</h3><p>运行<code>docker ps -a</code>，可以看到以下输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                                                        COMMAND                  CREATED             STATUS                       PORTS                                         NAMES</span><br><span class="line">645070877c6c        registry.cn-hangzhou.aliyuncs.com/onlinejudge/oj_backend     <span class="string">&quot;/bin/sh -c &#x27;sh /app…&quot;</span>   About an hour ago   Up About an hour (healthy)             0.0.0.0:443-&gt;1443/tcp, 0.0.0.0:80-&gt;8000/tcp   oj-backend</span><br><span class="line">b6fc725b2417        registry.docker-cn.com/library/redis:4.0-alpine              <span class="string">&quot;docker-entrypoint.s…&quot;</span>   About an hour ago   Up About an hour             6379/tcp                                      oj-redis</span><br><span class="line">3402b59b96d3        registry.docker-cn.com/library/postgres:10-alpine            <span class="string">&quot;docker-entrypoint.s…&quot;</span>   About an hour ago   Up About an hour             5432/tcp                                      oj-postgres</span><br><span class="line">7c399af69344        registry.cn-hangzhou.aliyuncs.com/onlinejudge/judge_server   <span class="string">&quot;/bin/sh -c &#x27;/bin/ba…&quot;</span>   About an hour ago   Up About an hour (healthy)   8080/tcp                                      judge-server</span><br></pre></td></tr></table></figure>

<p><code>NAMES</code>就是容器的名称，后面会经常用到。<code>STATUS</code>就是当前容器的运行状态，<code>Up xxx (healthy)</code>就是正常运行状态，<code>unhealthy</code>或<code>Exited (x) xxx</code>就是退出状态。</p>
<p>注意下面使用 <code>&#123;CONTAINER_NAME&#125;</code> 的地方，都使用对应的名字替换，需要去除大括号。</p>
<h3 id="进入正在运行的容器"><a href="#进入正在运行的容器" class="headerlink" title="进入正在运行的容器"></a>进入正在运行的容器</h3><p>然后运行<code>docker exec -it &#123;CONTAINER_NAME&#125; /bin/sh</code>，比如 <code>docker exec -it oj-backend /bin/sh</code>。</p>
<h3 id="容器异常退出"><a href="#容器异常退出" class="headerlink" title="容器异常退出"></a>容器异常退出</h3><p>容器<code>STATUS</code>显示为<code>Exited(x) xxx</code>，运行<code>docker logs &#123;CONTAINER_NAME&#125;</code>，查看错误信息。</p>
<h3 id="docker-compose-启动的时候报错-‘module’-object-has-on-attribute-‘connection’"><a href="#docker-compose-启动的时候报错-‘module’-object-has-on-attribute-‘connection’" class="headerlink" title="docker-compose 启动的时候报错 ‘module’ object has on attribute ‘connection’"></a>docker-compose 启动的时候报错 ‘module’ object has on attribute ‘connection’</h3><p>尝试运行 <code>pip install --upgrade pip &amp;&amp; pip install -U urllib3</code>，然后再重试看看。</p>
<h3 id="Invalid-token"><a href="#Invalid-token" class="headerlink" title="Invalid token"></a>Invalid token</h3><p>请查看<code>docker-compose.yml</code>内的<code>JUDGE_SERVER_TOKEN</code>与<code>TOKEN</code>是否一致</p>
<h3 id="80-或者-443-端口被占用导致-docker-无法启动"><a href="#80-或者-443-端口被占用导致-docker-无法启动" class="headerlink" title="80 或者 443 端口被占用导致 docker 无法启动"></a>80 或者 443 端口被占用导致 docker 无法启动</h3><p>错误信息 <code>bind 0.0.0.0:80 failed, port is already allocated</code></p>
<p>修改 docker-compose 中 <code>ports</code> 相关的配置，比如 <code>0.0.0.0:80:8080</code> 可以修改为 <code>0.0.0.0:8020:8080</code>，冒号后面的端口号不会冲突请勿改动。</p>
<h3 id="我的浏览器不显示数据或者显示异常"><a href="#我的浏览器不显示数据或者显示异常" class="headerlink" title="我的浏览器不显示数据或者显示异常"></a>我的浏览器不显示数据或者显示异常</h3><p>请使用 Chrome 或 Firefox 使用本OJ，如不能解决，请反馈问题。</p>
<h3 id="如何解决-oj-上运行错误但是本地成功的问题"><a href="#如何解决-oj-上运行错误但是本地成功的问题" class="headerlink" title="如何解决 oj 上运行错误但是本地成功的问题"></a>如何解决 oj 上运行错误但是本地成功的问题</h3><ul>
<li>90% 的可能性是代码的bug，本地没有触发，尤其是是本地没有完整测试数据和相同的运行环境的情况下。</li>
<li>如果是 <code>Runtime Error</code>，可能是代码运行过程中 crash，如果提示 <code>signal=31</code>，可能是触发了禁止使用的系统调用。通过 <code>dmesg</code> 可以看到系统调用号。</li>
<li>如果实在想看到代码运行结果，可以修改 <code>docker-compose.yml</code>，去除 <code>judger_debug=1</code> 的注释，然后 <code>docker-compose up -d</code>。重新提交之后，<code>docker exec -it judge-server bash</code> <code>cd /judger/run</code> 就可以看到很多文件夹了，可以找到自己的代码和运行结果。调试完请注释这一行并重新 <code>up -d</code>，否则每次的运行结果都会保留。</li>
</ul>
<h3 id="如何调整数据库参数"><a href="#如何调整数据库参数" class="headerlink" title="如何调整数据库参数"></a>如何调整数据库参数</h3><p>在以下情况下，需要考虑调整数据库参数</p>
<ul>
<li><p>机器配置较高，比如 CPU 超过 4 核或内存超过 4G</p>
</li>
<li><p>后端报错数据库连接数不够 <code>too many clients already</code></p>
<p>请参考 <a class="link"   href="https://pgtune.leopard.in.ua/" >https://pgtune.leopard.in.ua<i class="fas fa-external-link-alt"></i></a> 选择 DB Version 10，Number of Connections 为 20 倍 CPU 核数，其他的参数按照实际情况填写。</p>
<p>然后将右侧的参数更新到 <code>OnlineJudgeDeploy/OnlineJudgeDeploy/data/postgres/postgresql.conf</code> 文件中，注意原先配置部分是注释掉的，需要将开头的 <code>#</code> 删除，<code>docker-compose restart oj-postgres</code> 即可。</p>
</li>
</ul>
<hr>
]]></content>
  </entry>
  <entry>
    <title>PostgreSQL</title>
    <url>/iSTEP.github.io/2021/08/01/PostgreSQL/</url>
    <content><![CDATA[<h5 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h5><p>现在称为 PostgreSQL 的对象关系数据库管理系统源自加州大学伯克利分校的 POSTGRES 项目，经过二十多年的发展，现已成为最先进的开源数据库。其发展经历了三个阶段：The Berkeley POSTGRES Project、Postgres95 和 PostgreSQL。</p>
<h6 id="The-Berkeley-POSTGRES-Project"><a href="#The-Berkeley-POSTGRES-Project" class="headerlink" title="The Berkeley POSTGRES Project"></a>The Berkeley POSTGRES Project</h6><p>POSTGRES 项目开始于1986年，并经历了几次重要的发布。第一个 demo 系统于1987年开始运作；版本1于1989年6月发布给少数外部用户；版本2于1990年6月发布，重新设计了规则系统；版本3出现在1991年，增加了对多个存储管理器的支持，改进了查询执行器，重写了规则系统。</p>
<p>1993年，POSTGRES 外部用户社区的规模几乎翻了一番，维护源代码占用了大量时间。为了减轻这种支持负担，POSTGRES 项目以版本4.2结束。</p>
<h6 id="Postgres95"><a href="#Postgres95" class="headerlink" title="Postgres95"></a>Postgres95</h6><p>1994年，Andrew Yu 和 Jolly Chen 在 POSTGRES 中添加了一个 SQL 语言解释器，次年将该项目重命名为 Postgres95 后发布到网络上，从此走上了开放源代码的光明大道。</p>
<p>Postgres95 完全由 C 语言编写，代码量缩小了25％。许多内部更改提高了性能和可维护性。与 POSTGRES 4.2 版相比，Postgres95 1.0.x 版本的运行速度提高了约30％−50％。</p>
<h6 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h6><p>很明显 Postgres95 这个名字经不起时间的考验，1996年开发者选择了一个新名称 PostgreSQL 来反映原始 POSTGRES 与具有 SQL 功能的更新版本之间的关系。</p>
<p>Postgres95 开发过程中的重点是识别和理解服务器代码中存在的问题。 PostgreSQL 的重点已转移到增强特性和功能。</p>
<h5 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h5><p>PostgreSQL 提供了许多功能，旨在帮助开发人员构建应用程序以及管理数据，且无论数据的规模有多大。除了免费和开源之外，PostgreSQL 还具有高度可扩展性。例如，你可以定义自己的数据类型，构建自定义函数，甚至可以编写来自不同编程语言的代码，而无需重新编译数据库！</p>
<p>PostgreSQL 尽力地遵循 SQL 语言标准，支持 SQL 标准所需的许多功能，但有时语法或功能略有不同。下面是 PostgreSQL 主要的功能特性：</p>
<h6 id="数据类型（Data-Types）"><a href="#数据类型（Data-Types）" class="headerlink" title="数据类型（Data Types）"></a>数据类型（Data Types）</h6><p>PostgreSQL 支持多种不同类型的数据，主要包括：</p>
<ul>
<li>基本数据类型：Integer、Numeric、String、Boolean；</li>
<li>结构化类型：Date/Time、Array、Range、UUID；</li>
<li>文档类型：JSON/JSONB、XML、Key-value；</li>
<li>几何类型：Point、Line、Circle、Polygon。</li>
<li>……</li>
</ul>
<h6 id="数据完整性（Data-Integrity）"><a href="#数据完整性（Data-Integrity）" class="headerlink" title="数据完整性（Data Integrity）"></a>数据完整性（Data Integrity）</h6><p>PostgreSQL 提供了一系列数据完整性检查机制，主要包括：</p>
<ul>
<li>UNIQUE、NOT NULL；</li>
<li>Primary Keys、Foreign Keys；</li>
<li>Exclusion Constraints。</li>
<li>……</li>
</ul>
<h6 id="并发和性能（Concurrency、Performance）"><a href="#并发和性能（Concurrency、Performance）" class="headerlink" title="并发和性能（Concurrency、Performance）"></a>并发和性能（Concurrency、Performance）</h6><p>PostgreSQL 提供了丰富的性能优化机制和功能，主要包括：</p>
<ul>
<li>索引：B-tree、Multicolumn、Expressions、Partial；</li>
<li>事务、嵌套事务；</li>
<li>并发读查询、表分区；</li>
<li>表达式即时编译。</li>
<li>……</li>
</ul>
<h6 id="安全性（Security）"><a href="#安全性（Security）" class="headerlink" title="安全性（Security）"></a>安全性（Security）</h6><p>PostgreSQL 支持多种认证方式以提升安全性，主要包括：</p>
<ul>
<li>认证方式：GSSAPI、SSPI、LDAP、SCRAM-SHA-256 and more；</li>
<li>健壮的访问控制系统。</li>
<li>……</li>
</ul>
<p>事实证明，PostgreSQL 在可管理的数据量和可容纳的并发用户数量方面具有高度可扩展性，生产环境中有管理着数 TB 数据的 PostgreSQL 集群案例。</p>
<hr>
<h5 id="安装-PostgreSQL"><a href="#安装-PostgreSQL" class="headerlink" title="安装 PostgreSQL"></a>安装 PostgreSQL</h5><p>安装 PostgreSQL 的方法有很多，这里介绍的方法是使用 apt 安装。默认情况下，PostgreSQL 在所有的 Ubuntu 版本中都可用，也就是说我们不用添加额外的软件源，直接使用下面的命令安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install -y postgresql</span><br></pre></td></tr></table></figure>

<p>在9.5版本中主要包含以下软件包：</p>
<ul>
<li>postgresql-client-9.5 ：一些客户端库和客户端可执行文件（PostgreSQL 基于 C/S 架构）；</li>
<li>postgresql-9.5 ：核心的数据库服务；</li>
<li>postgresql-contrib-9.5 ：一些额外的模块。</li>
</ul>
<p>除了安装以上必要的软件包到文件系统，安装程序还执行了很多默认的初始化动作，包括添加 Linux 用户、创建数据库集群、配置 server 自启动服务、启动后台 server 等。</p>
<h5 id="启动-PostgreSQL-服务"><a href="#启动-PostgreSQL-服务" class="headerlink" title="启动 PostgreSQL 服务"></a>启动 PostgreSQL 服务</h5><p>1.<strong>添加 Linux 用户</strong>。PostgreSQL <strong>不允许</strong> root 用户管理数据库。添加新的 Linux 用户的目的是保护数据，并且在数据库集群中产生一个同名的数据库管理员用户（见第二步）。</p>
<p>数据库用户和 Linux 用户没有必然的联系（关于数据库用户的详细内容，将在以后的实训中介绍）。这里我们使用安装数据库时自动添加的 postgres 用户即可。</p>
<p>2.<strong>创建数据库集群</strong>（Database Cluster）。数据库集群位于磁盘上的一个目录，其中包含多个数据库和各种配置文件。数据库集群由 server 管理。执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个空目录</span></span><br><span class="line">sudo mkdir -p /usr/<span class="built_in">local</span>/pgsql/test_cluster</span><br><span class="line"><span class="comment"># 更改目录拥有者</span></span><br><span class="line">sudo chown postgres /usr/<span class="built_in">local</span>/pgsql/test_cluster</span><br><span class="line"><span class="comment"># 初始化数据库集群</span></span><br><span class="line">sudo -u postgres /usr/lib/postgresql/9.5/bin/initdb -D /usr/<span class="built_in">local</span>/pgsql/test_cluster</span><br></pre></td></tr></table></figure>

<p>命令说明：</p>
<ul>
<li>上述命令的目的是在磁盘目录 /usr/local/pgsql/test_cluster 中创建一个数据库集群；</li>
<li>前面提到，PostgreSQL 不允许 root 用户管理数据库。所以必须把目录的所有者改为 postgres，也就是说以后 postgres 是这个数据库集群的拥有者；</li>
<li>创建数据库集群的关键命令是 initdb，命令所在位置为 /usr/lib/postgresql/9.5/bin。-D 选项指明创建集群的目录；</li>
<li>由于 initdb 命令认为，命令的执行者就是数据库集群的拥有者，所以使用了 sudo -u postgres 语法；</li>
<li>执行 sudo 命令需要 sudoer 权限；</li>
<li>数据库集群初始化完成后，该目录下会新增很多内容，包括：两个数据库，分别为 postgres 和 template1；若干配置文件；创建一个和当前 Linux 用户同名的数据库集群管理员，即 postgres。</li>
</ul>
<p>3.<strong>启动 server</strong>。键入如下命令，便可以启动一个 server 负责管理上面创建的数据库集群。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭当前后台的server</span></span><br><span class="line">service postgresql stop</span><br><span class="line"><span class="comment"># 启动server</span></span><br><span class="line">sudo -u postgres /usr/lib/postgresql/9.5/bin/pg_ctl -D /usr/<span class="built_in">local</span>/pgsql/test_cluster start</span><br><span class="line"><span class="comment"># 关闭server</span></span><br><span class="line">sudo -u postgres /usr/lib/postgresql/9.5/bin/pg_ctl -D /usr/<span class="built_in">local</span>/pgsql/test_cluster stop</span><br></pre></td></tr></table></figure>

<p>命令说明：</p>
<ul>
<li>由于安装软件时，后台自动开启了一个 server，为避免端口冲突，首先应关闭它；</li>
<li>管理 server 运行状态的关键命令是 pg_ctl。-D 选项指明集群的目录。开启 server 使用 start，关闭 server 使用 stop。</li>
</ul>
<p>使用如下命令可以查看 server 是否正在后台运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep postgres</span><br></pre></td></tr></table></figure>

<p>具体效果如图1所示：</p>
<center><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yzketx/image-markdown/raw/master/img/241757.png"
                      alt="图1" style="zoom:80%;" 
                > 图 1</center>

<hr>
<h5 id="和-server-交互"><a href="#和-server-交互" class="headerlink" title="和 server 交互"></a>和 server 交互</h5><ul>
<li>核心是服务进程，即前面一直提到的 server 部分。服务进程管理所有的数据库文件、接受来自客户端应用的连接请求，代表这些客户端完成数据库的操作。这个服务端进程就是 postgres，其执行程序在 /usr/local/postgres/9.5/bin 目录下；</li>
<li>外围是客户端程序，也称为前端。客户端程序是多种多样的，可以是基于命令行的工具、图形界面程序、web 服务器（向服务进程发送请求以展示动态页面）、或者是特殊的数据库管理工具。PostgreSQL 自带了一些客户端程序，我们也可以自己开发这样的程序。</li>
</ul>
<p>主要使用最简单同时也是最强大的命令行交互工具和 server 通信，这个工具称为 psql。它允许你使用 SQL 语言给 server 发送请求（可以是远程 server）。</p>
<p>启动 psql 的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">psql -h &lt;server_ip&gt; -p &lt;port&gt; -U &lt;db_user&gt; -d &lt;database_name&gt;</span><br></pre></td></tr></table></figure>

<p>具体语义说明：</p>
<ul>
<li>psql 还有很多选项可用，这里仅列出最常用的几个；</li>
<li>-h 选项指明 server 所在机器的 ip，可以省略，默认为本机 ip。-p 选项指明 server 的端口号，也可以省略，默认为5432；</li>
<li>-U 选项指定需要登录的数据库用户，可以省略，默认登录和当前 Linux 用户同名的数据库用户；</li>
<li>-d 选项指明你想连接的数据库。可以省略，默认连接和数据库用户同名的数据库。</li>
</ul>
<p>应用示例：</p>
<p>由于安装完软件后，系统中会有一个默认的 server 在后台运行，其管理员为 postgres。</p>
<p>所以如果你要登录到数据库用户 postgres，并连接到数据库 postgres，只需要以 postgres 的身份执行 psql，其他选项都使用默认参数即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -u postgres psql</span><br></pre></td></tr></table></figure>

<p>示例说明：</p>
<ul>
<li>默认情况下，数据库管理员登录认证的方式为 peer。其含义是，本地 Linux 用户可以直接登录到同名的数据库用户，无需输入数据库用户的密码；</li>
</ul>
<p>示例效果如图2所示：</p>
<center><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yzketx/image-markdown/raw/master/img/241924.png"
                      alt="图2" style="zoom:80%;" 
                > 图 2</center>

<h5 id="修改数据库用户密码"><a href="#修改数据库用户密码" class="headerlink" title="修改数据库用户密码"></a>修改数据库用户密码</h5><p>修改用户密码的示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#首先连接到数据库</span></span><br><span class="line">sudo -u postgres psql postgres</span><br><span class="line"><span class="comment">#然后在交互环境中修改密码，若修改成功则打印出ALTER ROLE字样</span></span><br><span class="line">&gt; postgres=<span class="comment"># ALTER USER postgres WITH PASSWORD &#x27;postgres&#x27;;</span></span><br><span class="line"><span class="comment">#退出交互环境</span></span><br><span class="line">&gt; postgres=<span class="comment"># q</span></span><br></pre></td></tr></table></figure>

<p>具体语义说明：</p>
<ul>
<li><p>语法的大写部分，是语法规定的内容。此处使用大写是为了突出语法，实际上 SQL 语言<strong>不区分大小写</strong>；</p>
</li>
<li><p>新密码用单引号包起来，注意语句的最后要<strong>加上分号</strong>；</p>
</li>
<li><p>使用元命令 q 退出 psql ，元命令不需要分号。</p>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/iSTEP.github.io/2021/08/01/Redis/</url>
    <content><![CDATA[<p>Redis的index-1中的keys中保存有django.contrib.sessions.cache等数据</p>
<p>即Django的会话框架将缓存临时保存在次，同时借助restframework搭建认证框架。</p>
<h3 id="Redis中的数据结构"><a href="#Redis中的数据结构" class="headerlink" title="Redis中的数据结构"></a>Redis中的数据结构</h3><hr>
<h5 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h5><p><code>Redis </code>是一个速度非常快的非关系型数据库（<code>non-relational database</code>），它可以存储键（<code>key</code>）和五种不同类型的值（<code>value</code>）之间的映射（<code>mapping</code>），可基于内存存储亦可持久化到硬盘的日志型，<code>Key-Value</code> 数据库。</p>
<h6 id="Redis与其他数据库的对比"><a href="#Redis与其他数据库的对比" class="headerlink" title="Redis与其他数据库的对比"></a>Redis与其他数据库的对比</h6><p>如果你使用过关系型数据库，例如：<code>Mysql</code>，那么你肯定写过关联两张表数据的查询语句。而 <code>Redis </code>属于 <code>NoSQL</code>，它不使用表，也不会预定义数据模式或强制用户对 <code>Redis </code>的各种数据进行关联。</p>
<blockquote>
<p><code>NoSQL</code>（<code>Not Only SQL</code>）</p>
</blockquote>
<blockquote>
<p>意指“不仅仅是<code>SQL</code>”，其泛指非关系型数据库，主要分为四类：键值（<code>Key-Value</code>）存储数据库，列存储数据库，文档型数据库，图形（<code>Graph</code>）数据库。</p>
</blockquote>
<p><code>Redis </code>也经常与高性能键值缓存服务器 <code>memcached</code> 做比较：两者均可用于存储键值映射，性能相差也甚少，但 <code>Redis </code>能存储除普通字符串值之外的四种数据结构，而 <code>memcached</code> 只能存储普通的字符串值。这些不同使得 <code>Redis </code>能够解决更为广泛的问题，而且既能作为主数据库使用，也可以作为辅助数据库使用。</p>
<p>我们通过一张表来对比常用的数据库与缓存服务器：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>数据存储选项</th>
<th>查询类型</th>
<th>附加功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>Redis</code></td>
<td>基于内存的非关系型数据库</td>
<td>字符串、列表、集合、哈希、有序集合</td>
<td>针对数据类型有专属命令，另有批量操作和不完全的事务支持</td>
<td>发布与订阅、复制、持久化、脚本扩展</td>
</tr>
<tr>
<td><code>memcached</code></td>
<td>基于内存的键值<strong>缓存</strong></td>
<td>键值映射</td>
<td>创建、读取、更新、删除等</td>
<td>多线程支持</td>
</tr>
<tr>
<td><code>MySQL</code></td>
<td>关系型数据库</td>
<td>数据表、视图等</td>
<td>查询、插入、更新、删除、内置函数、自定义存储过程等</td>
<td>支持 <code>ACID</code> 性质、复制等</td>
</tr>
<tr>
<td><code>MongoDB</code></td>
<td>基于硬盘的非关系型文档存储数据库</td>
<td>无 <code>schema</code> 的 <code>BSON</code> 文档</td>
<td>创建、读取、更新、删除、条件查询等</td>
<td>复制、分片、空间索引等</td>
</tr>
</tbody></table>
<h6 id="Redis的特性"><a href="#Redis的特性" class="headerlink" title="Redis的特性"></a>Redis的特性</h6><p>由于 <code>Redis </code>是内存型数据库，在使用之前就要考虑当服务器被关闭时，服务器存储的数据是否能保留。Redis 拥有两种不同形式的持久化方法，都可以用紧凑的格式将数据写入硬盘：</p>
<ul>
<li><p><code>RDB</code>持久化</p>
<ul>
<li>在指定的时间间隔内生成数据集的时间点快照</li>
</ul>
</li>
<li><p><code>AOF</code>持久化</p>
<ul>
<li>记录服务器执行的所有写操作命令</li>
<li>新命令会被<strong>追加</strong>到文件的末尾</li>
<li>在服务器启动时，通过重新执行这些命令还原数据集</li>
</ul>
</li>
</ul>
<p>除此之外，为了扩展 <code>Redis </code>的读性能，并为 <code>Redis </code>提供故障转移支持，<code>Redis </code>实现了主从复制特性：</p>
<ul>
<li>执行复制的从服务器连接主服务器<ul>
<li>接收主服务器发送的初始副本</li>
<li>接收主服务器执行的所有写命令</li>
</ul>
</li>
<li>在从服务器上执行所有写命令，实时更新数据库</li>
<li>读命令可以向任意一个从服务器发送</li>
</ul>
<h5 id="快速安装-Redis-与-Python"><a href="#快速安装-Redis-与-Python" class="headerlink" title="快速安装 Redis 与 Python"></a>快速安装 Redis 与 Python</h5><p>为了避免安装到旧版 <code>Redis </code>的问题，我们直接使用源码编译安装 <code>Redis</code>，首先你需要获取并安装 <code>make</code> 等一系列构建工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update$ sudo apt-get install make gcc python-dev</span><br></pre></td></tr></table></figure>

<p>构建工具安装完毕后，你需要执行以下操作：</p>
<ul>
<li>从 <code>https://redis.io/download</code> 下载最新的稳定版本 <code>Redis </code>源码</li>
<li>解压源码，编译、安装并启动 <code>Redis </code></li>
<li>下载并安装 <code>Python</code> 语言的 <code>Redis </code>客户端库</li>
</ul>
<p>其中，安装 <code>Redis </code>的过程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~:$ wget -q http://download.redis.io/releases/redis-5.0.0.tar.gz</span><br><span class="line">~:$ tar -xzf redis-5.0.0.tar.gz</span><br><span class="line">~:$ <span class="built_in">cd</span> redis-5.0.0  <span class="comment"># 注意观察编译消息，最后不应该产生任何错误（`Error`）</span></span><br><span class="line">~/redis-5.0.0:$ make  <span class="comment"># 注意观察安装消息，最后不应该产生任何错误（`Error`）</span></span><br><span class="line">~/redis-5.0.0:$ sudo make install  <span class="comment"># 启动 Redis 服务器，注意通过日志确认 Redis 顺利启动</span></span><br><span class="line">~/redis-5.0.0:$ redis-server redis.conf</span><br></pre></td></tr></table></figure>

<p>除了上述的启动 Redis 服务器方式，你还可以通过 Redis 默认的配置在后台启动它（常用启动方式）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ redis-server &amp;</span><br></pre></td></tr></table></figure>

<p>因为近几年发布的 <code>Ubuntu</code> 和 <code>Debian</code> 都预装了 <code>Python 2.6</code> 或 <code>Python 2.7</code>，所以你不再需要花时间去安装 <code>Python</code>。你可以通过一个名为 <code>setuptools</code> 的辅助包更方便的下载和安装 <code>Redis </code>客户端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~:$ sudo python -m easy_install redis hiredis</span><br></pre></td></tr></table></figure>

<p>这里的 <code>redis</code> 包为 <code>Python</code> 提供了连接 <code>Redis </code>的接口，<code>hiredis</code> 包则是可选的，它是一个使用 <code>C</code> 语言编写的高性能 <code>Redis </code>客户端。</p>
<h5 id="Redis数据结构简介"><a href="#Redis数据结构简介" class="headerlink" title="Redis数据结构简介"></a>Redis数据结构简介</h5><p><code>Redis </code>的五种数据结构分别是：</p>
<ul>
<li>字符串（<code>STRING</code>）</li>
<li>列表（<code>LIST</code>）</li>
<li>集合（<code>SET</code>）</li>
<li>哈希（<code>HASH</code>）</li>
<li>有序集合（<code>ZSET</code>）</li>
</ul>
<p><code>ZSET</code> 可以说是 <code>Redis </code>特有的数据结构，这里简要介绍他们的功能和小部分命令。他们的存储的值如下：</p>
<table>
<thead>
<tr>
<th>结构类型</th>
<th align="left">存储的值</th>
</tr>
</thead>
<tbody><tr>
<td><code>STRING</code></td>
<td align="left">字符串、整数或浮点数</td>
</tr>
<tr>
<td><code>LIST</code></td>
<td align="left">一个链表，上面的每个节点都是一个字符串</td>
</tr>
<tr>
<td><code>SET</code></td>
<td align="left">包含若干个字符串的无序集合，且集合中的元素都是唯一的</td>
</tr>
<tr>
<td><code>HASH</code></td>
<td align="left">包含键值对的无序散列表</td>
</tr>
<tr>
<td><code>ZSET</code></td>
<td align="left">成员中的字符串与分值的有序映射，其排序由分值决定</td>
</tr>
</tbody></table>
<p>在安装完 <code>Redis </code>并启动了 <code>redis-server</code> 后，我们可以使用 <code>redis-cli</code> 控制台与 <code>Redis </code>进行交互，其启动方式是在终端中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ redis-cli</span><br></pre></td></tr></table></figure>

<p>其会默认连接本机 <code>6379</code> 端口启动的 <code>Redis </code>服务器，接下俩你可以使用它来体验 <code>Redis </code>各种数据结构和其命令的使用。</p>
<h6 id="Redis中的字符串"><a href="#Redis中的字符串" class="headerlink" title="Redis中的字符串"></a>Redis中的字符串</h6><p><code>STRING</code> 拥有一些和其他键值存储相似的命令，比如 <code>GET</code>（获取值），<code>SET</code>（设置值），<code>DEL</code>（删除值）等，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ redis<span class="operator">-</span>cli</span><br><span class="line">redis<span class="operator">-</span>cli <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> <span class="keyword">set</span> hello redis</span><br><span class="line">OK</span><br><span class="line">redis<span class="operator">-</span>cli <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> <span class="keyword">get</span> hello</span><br><span class="line">&quot;redis&quot;</span><br><span class="line">redis<span class="operator">-</span>cli <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> del hello</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line">redis<span class="operator">-</span>cli <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> <span class="keyword">get</span> hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>SET</code> 命令的第一个参数是键（<code>Key</code>），第二个参数是值（<code>Value</code>）</li>
<li>尝试获取不存在的键时会得到一个 <code>nil</code></li>
</ul>
<h6 id="Redis中的列表"><a href="#Redis中的列表" class="headerlink" title="Redis中的列表"></a>Redis中的列表</h6><p>就像前面所说的，<code>Redis </code>中的列表是一个“链表”，这和大多数编程语言相似。所以他们的操作也十分相似：</p>
<ul>
<li><code>LPUSH</code> 命令可用于将元素推入列表的左侧</li>
<li><code>RPUSH</code> 命令可将元素推入列表的右侧</li>
<li><code>LPOP</code> 和 <code>RPOP</code> 就分别从列表的左侧和右侧弹出元素</li>
<li><code>LINDEX</code> 可以获取<strong>指定位置</strong>上的元素</li>
<li><code>LRANGE</code> 可以获取<strong>指定范围</strong>的全部元素</li>
</ul>
<p>我们通过 <code>redis-cli</code> 来亲自体验：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> rpush testlist item</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> rpush testlist item2</span><br><span class="line">(<span class="type">integer</span>) <span class="number">2</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> rpush testlist item</span><br><span class="line">(<span class="type">integer</span>) <span class="number">3</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange testlist <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;item&quot;</span><br><span class="line"><span class="number">2</span>) &quot;item2&quot;</span><br><span class="line"><span class="number">3</span>) &quot;item&quot;</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lindex testlist <span class="number">1</span></span><br><span class="line">&quot;item2&quot;</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lpop testlist</span><br><span class="line">&quot;item&quot;</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> lrange testlist <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) &quot;item2&quot;</span><br><span class="line"><span class="number">2</span>) &quot;item&quot;</span><br></pre></td></tr></table></figure>

<p>我们可以看出，在列表中，元素可以重复出现。在后续的实训中，我们还会介绍更多列表命令，现在我们先来了解以下 <code>Redis </code>中的集合。</p>
<h6 id="Redis中的集合"><a href="#Redis中的集合" class="headerlink" title="Redis中的集合"></a>Redis中的集合</h6><p>集合和列表的区别就在于：列表可以存储多个相同的字符串，而集合通过散列表来保证存储的字符串都是各不相同的（这些散列表只有键，而没有对应的值）。</p>
<p>由于集合是无序的，所以我们只能通过统一的 <code>SADD</code> 命令将元素添加到集合中，<code>SREM</code> 命令将元素从集合中移除。你还可以通过：</p>
<ul>
<li><code>SMEMBERS</code> 命令获取到集合中的所有元素</li>
<li><code>SISMEMBER</code> 命令来判断一个元素是否已存在在集合中</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> sadd testset item</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> sadd testset item2</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> sadd testset item</span><br><span class="line">(<span class="type">integer</span>) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> smembers testset</span><br><span class="line"><span class="number">1</span>) &quot;item&quot;</span><br><span class="line"><span class="number">2</span>) &quot;item2&quot;</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> sismember testset item3</span><br><span class="line">(<span class="type">integer</span>) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> sismember testset item</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> srem testset item2</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> srem testset item2</span><br><span class="line">(<span class="type">integer</span>) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> smembers testset</span><br><span class="line"><span class="number">1</span>) &quot;item&quot;</span><br></pre></td></tr></table></figure>

<p>上面示例的集合中包含的元素少，所以执行 <code>SMEMBERS</code> 命令没有问题，一旦集合中包含的元素非常多时，<code>SMEMBERS</code> 命令的执行速度会很慢，所以要!!谨慎的使用这个命令。</p>
<h6 id="Redis中的哈希"><a href="#Redis中的哈希" class="headerlink" title="Redis中的哈希"></a>Redis中的哈希</h6><p>哈希可以存储多个键值对之间的映射。和字符串一样，哈希存储的值既可以是字符串又可以是数字值，并且可以对数字值进行自增/自减操作。</p>
<p>哈希就像是一个缩小版的 <code>Redis</code>，有一系列命令对哈希进行插入、获取、删除：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> hset testhash key1 value1(<span class="type">integer</span>) <span class="number">1</span>redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> hset testhash key2 value2(<span class="type">integer</span>) <span class="number">1</span>redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> hset testhash key1 newvalue(<span class="type">integer</span>) <span class="number">0</span>redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> hgetall testhash1) &quot;key1&quot;<span class="number">2</span>) &quot;newvalue&quot;<span class="number">3</span>) &quot;key2&quot;<span class="number">4</span>) &quot;value2&quot;redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> hdel testhash key2(<span class="type">integer</span>) <span class="number">1</span>redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> hget testhash key1&quot;newvalue&quot;redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> hgetall testhash1) &quot;key1&quot;<span class="number">2</span>) &quot;newvalue&quot;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><p><code>hset</code></p>
<p>用于插入元素</p>
<ul>
<li><p>第一个参数为该哈希的键名，如果该哈希不存在，则创建一个</p>
</li>
<li><p>第二个参数为哈希中的</p>
<p>域名</p>
<ul>
<li>如果不存在，则创建该域，并与第三个参数的值进行映射</li>
</ul>
</li>
</ul>
</li>
<li><p>如果存在，则使用第三个参数更新该域的值</p>
<ul>
<li>第三个参数为哈希中的值</li>
</ul>
</li>
<li><p><code>hgetall</code> 会获取到该哈希的所有<strong>域-值对</strong></p>
</li>
<li><p><code>hget</code> 用于获取哈希中的某一个域</p>
</li>
<li><p><code>hdel</code> 用户<strong>删除</strong>哈希中的某一个域</p>
</li>
</ul>
<h6 id="Redis中的有序集合"><a href="#Redis中的有序集合" class="headerlink" title="Redis中的有序集合"></a>Redis中的有序集合</h6><p>有序集合和哈希一样，也是存储键值对。</p>
<p>只是有序集合的键被称为成员（<code>member</code>），每个成员都是唯一的，有序集合的值则被称为分值（<code>score</code>），这个分值必须为浮点数。所以有序集合既可以通过成员访问元素，也可以通过分值来排序元素。</p>
<p>我们可以通过：</p>
<ul>
<li><code>ZADD</code> 命令将带有指定分值的成员添加到有序集合中</li>
<li><code>ZRANGE</code> 命令根据分值有序排列后的集合获取到<strong>指定范围</strong>的元素</li>
<li><code>ZRANGEBYSCORE</code> 命令获取<strong>指定分值范围</strong>内的元素</li>
<li><code>ZREM</code> 命令从有序集合中删除<strong>指定成员</strong></li>
</ul>
<p>我们也可以在 <code>redis-cli</code> 中验证上述命令的功能：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> zadd testzset <span class="number">100</span> member1(<span class="type">integer</span>) <span class="number">1</span>redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> zadd testzset <span class="number">200</span> member0(<span class="type">integer</span>) <span class="number">1</span>redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> zrange testzset <span class="number">0</span> <span class="number">-1</span> withscores1) &quot;member1&quot;<span class="number">2</span>) &quot;100&quot;<span class="number">3</span>) &quot;member0&quot;<span class="number">4</span>) &quot;200&quot;redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> zrangebyscore testzset <span class="number">0</span> <span class="number">150</span> withscores1) &quot;member1&quot;<span class="number">2</span>) &quot;100&quot;redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> zrem testzset member1(<span class="type">integer</span>) <span class="number">1</span>redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> zrange testzset <span class="number">0</span> <span class="number">-1</span> withscores1) &quot;member0&quot;<span class="number">2</span>) &quot;200&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/iSTEP.github.io/2021/08/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>iSTEP</title>
    <url>/iSTEP.github.io/2021/08/01/iSTEP/</url>
    <content><![CDATA[<h2 id="安装篇"><a href="#安装篇" class="headerlink" title="安装篇"></a>安装篇</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>OJ（OnlineJudge）是在线判题系统，很多学校或者机构打比赛都有自己的OJ系统。iSTEP项目基于QingdaoU开源项目<a class="link"   href="https://github.com/QingdaoU/OnlineJudge" >OnlineJudge<i class="fas fa-external-link-alt"></i></a>。</p>
<p><strong>项目物理环境</strong>：</p>
<p>阿里云ECS Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHz</p>
<p>4核 8G + 100G</p>
<h3 id="系统环境安装"><a href="#系统环境安装" class="headerlink" title="系统环境安装"></a>系统环境安装</h3><ul>
<li>pip</li>
<li>docker-compose (安装这个需要pip)</li>
<li>vim</li>
<li>git</li>
<li>curl</li>
<li>docker</li>
</ul>
<h4 id="Linux-环境"><a href="#Linux-环境" class="headerlink" title="Linux 环境"></a>Linux 环境</h4><details>
<summary>detail</summary>
pip
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install python3-pip</span><br><span class="line">pip install --upgrade pip  <span class="comment"># 升级一下pip</span></span><br></pre></td></tr></table></figure>
docker-compose
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install docker-compose  <span class="comment"># 或者pip3</span></span><br><span class="line">docker-compose version  <span class="comment"># 显示版本号，确认安装成功</span></span><br></pre></td></tr></table></figure>
vim
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure>
git
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure>
curl
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apy install curl</span><br></pre></td></tr></table></figure>
docker
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>
</details>

<ol>
<li><p>安装必要的依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install -y vim python3-pip curl git</span><br><span class="line">pip3 install --upgrade pip</span><br><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure></li>
<li><p>安装 Docker</p>
<p>使用脚本一键安装</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure>

<p>详细步骤参照： <a class="link"   href="https://docs.docker.com/install/" >https://docs.docker.com/install/<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ol>
<h4 id="Windows环境不推荐"><a href="#Windows环境不推荐" class="headerlink" title="Windows环境不推荐"></a>Windows环境不推荐</h4><p>Windows 下的安装仅供体验，勿在生产环境使用。如有必要，请使用虚拟机安装 Linux 并将 OJ 安装在其中。</p>
<p>以下教程仅适用于 Win10 x64 下的 <code>PowerShell</code></p>
<ol>
<li>安装 Windows 的 Docker 工具</li>
<li>右击右下角 Docker 图标，选择 Settings 进行设置</li>
<li>选择 <code>Shared Drives</code> 菜单，之后勾选你想安装 OJ 的盘符位置（例如勾选D盘），点击 <code>Apply</code></li>
<li>输入 Windows 的账号密码进行文件共享</li>
<li>安装 <code>Python</code>、<code>pip</code>、<code>git</code>、<code>docker-compose</code>，安装方法自行搜索。</li>
</ol>
<h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><ol>
<li><p>请选择磁盘空间富余的位置，运行下面的命令</p>
<p><em><strong>TODO: 替换为 iSTEP</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b 2.0 https://github.com/QingdaoU/OnlineJudgeDeploy.git &amp;&amp; cd OnlineJudgeDeploy</span><br></pre></td></tr></table></figure></li>
<li><p>启动服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li>
</ol>
<p>根据网速情况，大约5到30分钟就可以自动搭建完成，全程无需人工干预。</p>
<p>等命令执行完成，然后运行 <code>docker ps -a</code>，当看到所有的容器的状态没有 <code>unhealthy</code> 或 <code>Exited (x) xxx</code> 就代表 OJ 已经启动成功。</p>
<h3 id="尽情享用吧"><a href="#尽情享用吧" class="headerlink" title="尽情享用吧"></a>尽情享用吧</h3><p>通过浏览器访问服务器的 HTTP 80 端口或者 HTTPS 443 端口（默认可<a class="link"   href="http://localhost/" >本地访问<i class="fas fa-external-link-alt"></i></a>），就可以开始使用了。后台管理路径为<code>/admin</code>, 安装过程中自动添加的超级管理员用户名为 <code>root</code>，密码为 <code>rootroot</code>， <strong>请务必及时修改密码</strong>。</p>
<p><a class="link"   href="https://opensource.qduoj.com/#/onlinejudge/guide/deploy" >这里是QingDaoU的文档<i class="fas fa-external-link-alt"></i></a></p>
<hr>
<h2 id="部署篇"><a href="#部署篇" class="headerlink" title="部署篇"></a>部署篇</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><table>
<thead>
<tr>
<th align="left">文件夹</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">build</td>
<td align="left">项目构建相关webpack相关</td>
</tr>
<tr>
<td align="left">config</td>
<td align="left">项目配置目录，端口之类的</td>
</tr>
<tr>
<td align="left">deploy</td>
<td align="left">一部分配置文件</td>
</tr>
<tr>
<td align="left">node_modules</td>
<td align="left">npm加载的项目的依赖项，默认没有，执行npm install 后产生</td>
</tr>
<tr>
<td align="left">package.json</td>
<td align="left">项目配置文件</td>
</tr>
<tr>
<td align="left">README.md</td>
<td align="left">项目说明文档</td>
</tr>
<tr>
<td align="left">src</td>
<td align="left">二次开发的主要目录，页面等</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">静态文件，js,css文件</td>
</tr>
<tr>
<td align="left">dist</td>
<td align="left">打包后的文件，用于部署，执行npm run build 后产生</td>
</tr>
</tbody></table>
<h4 id="Linux安装指定版本node-js（npm）"><a href="#Linux安装指定版本node-js（npm）" class="headerlink" title="Linux安装指定版本node.js（npm）"></a>Linux安装指定版本node.js（npm）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash  -  <span class="comment"># 8可改为需要的版本，本项目要求8</span></span><br><span class="line">sudo apt-get install -y nodejs  <span class="comment"># ubuntu</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Windows只需下载相应文件，添加环境变量即可：</p>
<p><code>系统属性=&gt;高级=&gt;环境变量=&gt;系统变量=&gt;选择 &#39;PATH&#39; 编辑=&gt;添加 node.js 安装路径</code></p>
<p><a class="link"   href="https://nodejs.org/zh-cn/download/releases/" >以往的版本 | Node.js (nodejs.org)<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h4 id="本地运行前端"><a href="#本地运行前端" class="headerlink" title="本地运行前端"></a>本地运行前端</h4><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line"><span class="comment"># we use webpack DllReference to decrease the build time,</span></span><br><span class="line"><span class="comment"># this command only needs execute once unless you upgrade the package in build/webpack.dll.conf.js</span></span><br><span class="line"><span class="built_in">export</span> NODE_ENV=development </span><br><span class="line">npm run build:dll</span><br><span class="line"></span><br><span class="line"><span class="comment"># the dev-server will set proxy table to your backend</span></span><br><span class="line"><span class="built_in">export</span> TARGET=http://Your-backend</span><br><span class="line"></span><br><span class="line"><span class="comment"># serve with hot reload at localhost:8080</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line"><span class="comment"># we use webpack DllReference to decrease the build time,</span></span><br><span class="line"><span class="comment"># this command only needs execute once unless you upgrade the package in build/webpack.dll.conf.js</span></span><br><span class="line"><span class="built_in">set</span> NODE_ENV=development </span><br><span class="line">npm run build:dll</span><br><span class="line"></span><br><span class="line"><span class="comment"># the dev-server will set proxy table to your backend</span></span><br><span class="line"><span class="built_in">set</span> TARGET=http://Your-backend</span><br><span class="line"></span><br><span class="line"><span class="comment"># serve with hot reload at localhost:8080</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<h4 id="部署前端代码"><a href="#部署前端代码" class="headerlink" title="部署前端代码"></a>部署前端代码</h4><p>打开终端，将当前位置切换到相应的目录，然后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>等待一会，会提示成功，目录下会多出一个 dist 文件，结构如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  OnlineJudgeFE git:(master) ✗ tree dist  <span class="comment"># [sudo apt install tree]</span></span><br><span class="line">dist </span><br><span class="line">├── admin </span><br><span class="line">│   └── index.html </span><br><span class="line">├── index.html </span><br><span class="line">└── static    </span><br><span class="line">​	├── css    </span><br><span class="line">​	│   ├── admin.127f3da5b09451926728de2829ebb32e.css    </span><br><span class="line">​	│   ├── loader.css    </span><br><span class="line">​	│   ├── oj.0ba722f43ddbeb758cde2f9dc804455e.css    </span><br><span class="line">​	│   └── vendor.f033d6c4c74b6b40e92ca86f168fd0be.css    </span><br><span class="line">​	├── fonts   </span><br><span class="line">​	│   ├── KaTeX_AMS-Regular.3d8245d.woff2    </span><br><span class="line">​	│   ├── KaTeX_AMS-Regular.ac1d46d.woff</span><br><span class="line">....</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>将 <code>dist</code> 文件夹复制到服务器上某个目录下，比如 <code>~/backend/dist</code>，然后修改 <code>docker-compose.yml</code>，在 <code>oj-backend</code> 模块中的 <code>volumes</code> 中增加一行 <code>- ~/backend/dist:/app/dist</code> （冒号前面的请修改为实际的路径），然后 <code>docker-compose up -d</code> 即可。</p>
<p>注意，这种修改方式将覆盖容器内的前端文件，未来发布新版本前端的时候，请自行使用相同的方式更新。</p>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><table>
<thead>
<tr>
<th align="left">文件夹</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="配置本地后端环境"><a href="#配置本地后端环境" class="headerlink" title="配置本地后端环境"></a>配置本地后端环境</h4><h4 id="本地运行后端"><a href="#本地运行后端" class="headerlink" title="本地运行后端"></a>本地运行后端</h4><ol>
<li>Pycharm 克隆项目后可直接运行：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py runserver 127.0.0.1:8000</span><br><span class="line"><span class="comment"># OR: py manage.py runserver 127.0.0.1:8000 [运行的ip及端口]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="部署修改的后端代码"><a href="#部署修改的后端代码" class="headerlink" title="部署修改的后端代码"></a>部署修改的后端代码</h4><ol>
<li><p>通过<code>docker exec -it istep-backend sh</code>直接进入容器的<code>/app</code>目录下修改，可以借助<code>git</code>快速更新文件</p>
</li>
<li><p>或者，直接将<code>/app</code>目录挂载到本地进行修改：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"><span class="attr">oj-backend:</span></span><br><span class="line">	<span class="attr">volumes:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">本地目录:/app【docker</span> <span class="string">image中的位置】</span></span><br><span class="line"><span class="comment"># 注: 此时前端 [dist] 部署可直接在该目录修改</span></span><br></pre></td></tr></table></figure>

<p>如图：               <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/yzketx/image-markdown/raw/master/img/image-20210730203946862.png"
                      alt="image-20210730203946862" style="zoom:60%;" 
                ></p>
</li>
</ol>
<h3 id="打包镜像"><a href="#打包镜像" class="headerlink" title="打包镜像"></a>打包镜像</h3><h4 id="1-在此之前：我们需要在阿里云上注册一个docker的镜像仓库。"><a href="#1-在此之前：我们需要在阿里云上注册一个docker的镜像仓库。" class="headerlink" title="(1) 在此之前：我们需要在阿里云上注册一个docker的镜像仓库。"></a>(1) 在此之前：我们需要在阿里云上注册一个docker的镜像仓库。</h4><p><a class="link"   href="https://www.longkui.site/development/docker2/" >注册方法及简单使用方法请点这里。<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="2-然后我们需要将onlinejudge恢复到最初始的状态，就是你一键安装完毕那个状态。（如果你在上一步更改过docker-compose-yml-文件，记得改回来并重新docker-compose-up-d）"><a href="#2-然后我们需要将onlinejudge恢复到最初始的状态，就是你一键安装完毕那个状态。（如果你在上一步更改过docker-compose-yml-文件，记得改回来并重新docker-compose-up-d）" class="headerlink" title="(2) 然后我们需要将onlinejudge恢复到最初始的状态，就是你一键安装完毕那个状态。（如果你在上一步更改过docker-compose.yml 文件，记得改回来并重新docker-compose up -d）"></a>(2) 然后我们需要将onlinejudge恢复到最初始的状态，就是你一键安装完毕那个状态。（如果你在上一步更改过docker-compose.yml 文件，记得改回来并重新docker-compose up -d）</h4><h4 id="3-然后切换到我们修改过的前端的目录下-先查看下我们前端镜像的ID"><a href="#3-然后切换到我们修改过的前端的目录下-先查看下我们前端镜像的ID" class="headerlink" title="(3) 然后切换到我们修改过的前端的目录下,先查看下我们前端镜像的ID"></a>(3) 然后切换到我们修改过的前端的目录下,先查看下我们前端镜像的ID</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<h4 id="4-先把oj-backend的容器ID拷贝下来，一会要用。"><a href="#4-先把oj-backend的容器ID拷贝下来，一会要用。" class="headerlink" title="(4) 先把oj-backend的容器ID拷贝下来，一会要用。"></a>(4) 先把oj-backend的容器ID拷贝下来，一会要用。</h4><p>然后我们执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NODE_ENV=production npm run build:dll</span><br></pre></td></tr></table></figure>

<p>然后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<h4 id="5-打包完成后，我们还是把dist里的内容注入到docker容器中，我们执行"><a href="#5-打包完成后，我们还是把dist里的内容注入到docker容器中，我们执行" class="headerlink" title="(5) 打包完成后，我们还是把dist里的内容注入到docker容器中，我们执行"></a>(5) 打包完成后，我们还是把dist里的内容注入到docker容器中，我们执行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker cp ./dist  xxxxxxxxxxxxx:/app/</span><br><span class="line"><span class="comment">#这里 xxxxxxxxxxxxx 是我们刚才查看的oj-backend的容器ID，注意容器ID和冒号之间没有空格</span></span><br></pre></td></tr></table></figure>

<h4 id="6-然后将注入后的容器打包成本地镜像"><a href="#6-然后将注入后的容器打包成本地镜像" class="headerlink" title="(6) 然后将注入后的容器打包成本地镜像"></a>(6) 然后将注入后的容器打包成本地镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit -m <span class="string">&quot;提示信息&quot;</span> -a <span class="string">&quot;作者&quot;</span>   容器ID  镜像名称</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中, 容器ID是上面的 xxxxxxxxxxxxx, 镜像名称可以自己起一个, 成功之后会有一个值生成</span></span><br></pre></td></tr></table></figure>

<p>执行docker images后会有以下界面，我们复制刚才我们创建的镜像<code>ID: xxxxxxxxxxxxx</code>，一会要用。</p>
<h4 id="7-把打包好的镜像push到阿里云仓库"><a href="#7-把打包好的镜像push到阿里云仓库" class="headerlink" title="(7) 把打包好的镜像push到阿里云仓库"></a>(7) 把打包好的镜像push到阿里云仓库</h4><p>根据这篇文章中提到的阿里云仓库的注册方法,阿里提供了pull到仓库的方法, 建议打开你自己复制下来以备后用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker login --username=你的用户名 registry.xxx.aliyuncs.com</span><br><span class="line">sudo docker tag [镜像ID] registry.xxx.aliyuncs.com/你的命名空间/项目名字:[镜像版本号]</span><br><span class="line">sudo docker push registry.xxx.aliyuncs.com/你的命名空间/项目名字:[镜像版本号]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意,提交的时候没有中括号</span></span><br></pre></td></tr></table></figure>

<p>等待一会就push成功了。</p>
<p>在 阿里云控制台 “镜像版本” 可中看到上传的版本。</p>
<h4 id="8-拉取镜像"><a href="#8-拉取镜像" class="headerlink" title="(8) 拉取镜像"></a>(8) 拉取镜像</h4><p>复制上传完毕后的仓库的公有地址，把它替换到<code>docker-compose.yml</code>文件中 image 参数的位置，注意镜像地址要带版本号。</p>
<p>保存之后，就在一键安装文件夹下面重新 执行 docker-compose up -d 生效。</p>
<hr>
<h2 id="迁移篇"><a href="#迁移篇" class="headerlink" title="迁移篇"></a>迁移篇</h2><h3 id="如何备份"><a href="#如何备份" class="headerlink" title="如何备份"></a>如何备份</h3><p>为了保证数据安全，请定期备份。</p>
<p>OnlineJudgeDeploy 目录中的 <code>data</code> 文件夹是系统的所有的数据，包括日志，数据库，测试用例，上传的文件等，其中需要备份的数据为 <code>backend/public</code>，<code>backend/test_case</code> 两个目录。</p>
<p><strong>对于数据库，请不要使用复制数据库数据文件的方法</strong>。在最新的 OnlineJudgeDeploy 中，<code>backup</code> 目录提供了数据库导出 sql 文件备份脚本，请每次备份后检查生成的 sql 文件的大小和内容，确保备份成功。</p>
<p>请不要把备份数据和 OnlineJudge 系统放在同一台机器上，这样数据丢失的风险仍然较高。</p>
<h3 id="恢复备份"><a href="#恢复备份" class="headerlink" title="恢复备份"></a>恢复备份</h3><p>如果只是想不同机器之间迁移部署，<code>docker stop $(docker ps -aq)</code> 然后复制 <code>OnlineJudgeDeploy</code> 文件夹到新机器后重新 <code>docker-compose up -d</code> 即可。</p>
<p>如果要恢复数据，首先要保证已经新部署了一套 OnlineJudge，然后需要恢复数据和测试用例文件。</p>
<p>测试用例存储在 <code>data/backend/test_case</code> 文件夹中，覆盖即可。</p>
<p>在新的机器上执行下面的操作可以恢复数据库</p>
<ul>
<li><p><code>docker cp db_backup_xxxxxxx.sql oj-postgres:/root</code></p>
</li>
<li><p><code>docker exec -it oj-postgres bash</code></p>
</li>
<li><p><code>psql -U postgres</code> 然后运行 <code>drop database onlinejudge;</code> (<strong>请一定注意！！！看清楚在哪台机器上</strong>）</p>
</li>
<li><p><code>\q</code> 退出，然后 <code>psql -f /root/db_backup_xxxxxxx.sql -U postgres</code></p>
</li>
</ul>
<hr>
<h2 id="多个评测机"><a href="#多个评测机" class="headerlink" title="多个评测机"></a>多个评测机</h2><p>多个评测机只需确保两点即可正常运行:</p>
<ul>
<li>JudgeServer Token 一致</li>
<li>进行测试用例的多机同步</li>
</ul>
<p>iSTEP 使用 <code>rsync</code> 进行同步，步骤如下:</p>
<h3 id="在部署好的机器上开启测试用例同步-master-服务"><a href="#在部署好的机器上开启测试用例同步-master-服务" class="headerlink" title="在部署好的机器上开启测试用例同步 master 服务"></a>在部署好的机器上开启测试用例同步 master 服务</h3><p>在已经部署好的服务器上，修改 <code>OnlineJudgeDeploy</code> 里的 <code>docker-compose.yml</code> 文件</p>
<p>将下列代码合并进去(即添加一个service，注意缩进), 并运行<code>docker-compose up -d</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">oj-rsync-master:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/onlinejudge/oj_rsync</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">oj-rsync-master</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">$PWD/data/backend/test_case:/test_case:ro</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">$PWD/data/rsync_master:/log</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">RSYNC_MODE=master</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">RSYNC_USER=ojrsync</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">RSYNC_PASSWORD=CHANGE_THIS_PASSWORD</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;0.0.0.0:873:873&quot;</span></span><br></pre></td></tr></table></figure>

<p>请务必修改<code>RSYNC_PASSWORD</code>，否则会导致测试用例的泄露</p>
<h3 id="在新的机器上配置-JudgeServer-和测试用例同步-slave-服务"><a href="#在新的机器上配置-JudgeServer-和测试用例同步-slave-服务" class="headerlink" title="在新的机器上配置 JudgeServer 和测试用例同步 slave 服务"></a>在新的机器上配置 JudgeServer 和测试用例同步 slave 服务</h3><p>在新的的机器上按照 <code>OnlineJudgeDeploy</code> 项目初始化环境，修改 <code>docker-compose.yml</code>，只需要保留 <code>judge-server</code> 一个 service，然后添加下面的 service 到文件中。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">oj-rsync-slave:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/onlinejudge/oj_rsync</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">oj-rsync-slave</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">$PWD/data/backend/test_case:/test_case</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">$PWD/data/rsync_slave:/log</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">RSYNC_MODE=slave</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">RSYNC_USER=ojrsync</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">RSYNC_PASSWORD=CHANGE_THIS_PASSWORD</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">RSYNC_MASTER_ADDR=YOUR_BACKEND_ADDR</span></span><br></pre></td></tr></table></figure>

<p>请同步修改 <code>RSYNC_PASSWORD</code>，并将 <code>RSYNC_MASTER_ADDR</code> 修改为运行了 <code>oj-rsync-master</code> 服务的地址，不需要端口号，如 <code>example.com</code> 或者 <code>192.168.1.10</code>。</p>
<p>然后给 JudgeServer 添加</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;0.0.0.0:80:8080&quot;</span></span><br></pre></td></tr></table></figure>

<p>的端口配置，同时还需要修改</p>
<ul>
<li><code>SERVICE_URL</code> 为新的机器的地址</li>
<li><code>BACKEND_URL</code> 的域名为已部署好的主机的地址</li>
<li><code>TOKEN</code> 和已部署好主机 <code>TOKEN</code> 一致。</li>
</ul>
<p>运行 <code>docker-compose up -d</code> 即可启动一台新的 JudgeServer，<code>tail -f data/rsync_slave/rsync_slave.log</code> 可以看到测试用例同步进度，在已部署好主机的后台可以看到新的 JudgeServer 的心跳状态。</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>提问的智慧</title>
    <url>/iSTEP.github.io/2021/08/01/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/</url>
    <content><![CDATA[<p><strong>How To Ask Questions The Smart Way</strong></p>
<p>Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen</p>
<p>本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。</p>
<p>原文网址:<a class="link"   href="http://www.catb.org/~esr/faqs/smart-questions.html" >http://www.catb.org/~esr/faqs/smart-questions.html<i class="fas fa-external-link-alt"></i></a></p>
<p>Copyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu</p>
<p>本中文指南是基于原文 3.10 版以及 2010 年由 <a class="link"   href="https://github.com/gasolin" >Gasolin<i class="fas fa-external-link-alt"></i></a> 所翻译版本的最新翻译；</p>
<h2 id="原文版本历史"><a href="#原文版本历史" class="headerlink" title="原文版本历史"></a><a class="link"   href="https://github.com/ryanhanwu/smartquestions/blob/master/history.md" >原文版本历史<i class="fas fa-external-link-alt"></i></a></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E5%A3%B0%E6%98%8E">声明</a></li>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">在提问之前</a></li>
<li><a href="#%E5%BD%93%E4%BD%A0%E6%8F%90%E9%97%AE%E6%97%B6">当你提问时</a><ul>
<li><a href="#%E6%85%8E%E9%80%89%E6%8F%90%E9%97%AE%E7%9A%84%E8%AE%BA%E5%9D%9B">慎选提问的论坛</a></li>
<li><a href="#stack-overflow">Stack Overflow</a></li>
<li><a href="#%E7%BD%91%E7%AB%99%E5%92%8Circ%E8%AE%BA%E5%9D%9B">网站和IRC论坛</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%BD%BF%E7%94%A8%E9%A1%B9%E7%9B%AE%E9%82%AE%E4%BB%B6%E5%88%97%E8%A1%A8">第二步，使用项目邮件列表</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%9C%89%E6%84%8F%E4%B9%89%E4%B8%94%E6%8F%8F%E8%BF%B0%E6%98%8E%E7%A1%AE%E7%9A%84%E6%A0%87%E9%A2%98">使用有意义且描述明确的标题</a></li>
<li><a href="#%E4%BD%BF%E9%97%AE%E9%A2%98%E5%AE%B9%E6%98%93%E5%9B%9E%E5%A4%8D">使问题容易回复</a></li>
<li><a href="#%E7%94%A8%E6%B8%85%E6%99%B0%E6%AD%A3%E7%A1%AE%E7%B2%BE%E5%87%86%E5%B9%B6%E5%90%88%E6%B3%95%E8%AF%AD%E6%B3%95%E7%9A%84%E8%AF%AD%E5%8F%A5">用清晰、正确、精准并合法语法的语句</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%98%93%E4%BA%8E%E8%AF%BB%E5%8F%96%E4%B8%94%E6%A0%87%E5%87%86%E7%9A%84%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8F%91%E9%80%81%E9%97%AE%E9%A2%98">使用易于读取且标准的文件格式发送问题</a></li>
<li><a href="#%E7%B2%BE%E7%A1%AE%E7%9A%84%E6%8F%8F%E8%BF%B0%E9%97%AE%E9%A2%98%E5%B9%B6%E8%A8%80%E4%B9%8B%E6%9C%89%E7%89%A9">精确的描述问题并言之有物</a></li>
<li><a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a></li>
<li><a href="#%E5%88%AB%E5%8A%A8%E8%BE%84%E5%A3%B0%E7%A7%B0%E6%89%BE%E5%88%B0bug">别动辄声称找到Bug</a></li>
<li><a href="#%E5%8F%AF%E4%BB%A5%E4%BD%8E%E5%A3%B0%E4%B8%8B%E6%B0%94%E4%BD%86%E8%BF%98%E6%98%AF%E8%A6%81%E5%85%88%E5%81%9A%E5%8A%9F%E8%AF%BE">可以低声下气，但还是要先做功课</a></li>
<li><a href="#%E6%8F%8F%E8%BF%B0%E9%97%AE%E9%A2%98%E7%97%87%E7%8A%B6%E8%80%8C%E9%9D%9E%E7%8C%9C%E6%B5%8B">描述问题症状而非猜测</a></li>
<li><a href="#%E6%8C%89%E5%8F%91%E7%94%9F%E6%97%B6%E9%97%B4%E5%85%88%E5%90%8E%E5%88%97%E5%87%BA%E9%97%AE%E9%A2%98%E7%97%87%E7%8A%B6">按发生时间先后列出问题症状</a></li>
<li><a href="#%E6%8F%8F%E8%BF%B0%E7%9B%AE%E6%A0%87%E8%80%8C%E4%B8%8D%E6%98%AF%E8%BF%87%E7%A8%8B">描述目标而不是过程</a></li>
<li><a href="#%E5%88%AB%E8%A6%81%E6%B1%82%E4%BD%BF%E7%94%A8%E7%A7%81%E4%BA%BA%E7%94%B5%E9%82%AE%E5%9B%9E%E5%A4%8D">别要求使用私人电邮回复</a></li>
<li><a href="#%E6%B8%85%E6%A5%9A%E6%98%8E%E7%A1%AE%E7%9A%84%E8%A1%A8%E8%BE%BE%E4%BD%A0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E9%9C%80%E6%B1%82">清楚明确的表达你的问题以及需求</a></li>
<li><a href="#%E8%AF%A2%E9%97%AE%E6%9C%89%E5%85%B3%E4%BB%A3%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98%E6%97%B6">询问有关代码的问题时</a></li>
<li><a href="#%E5%88%AB%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%AE%B6%E5%BA%AD%E4%BD%9C%E4%B8%9A%E7%9A%84%E9%97%AE%E9%A2%98%E8%B4%B4%E4%B8%8A%E6%9D%A5">别把自己家庭作业的问题贴上来</a></li>
<li><a href="#%E5%8E%BB%E6%8E%89%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E6%8F%90%E9%97%AE%E5%8F%A5">去掉无意义的提问句</a></li>
<li><a href="#%E5%8D%B3%E4%BD%BF%E4%BD%A0%E5%BE%88%E6%80%A5%E4%B9%9F%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%A0%87%E9%A2%98%E5%86%99%E7%B4%A7%E6%80%A5">即使你很急也不要在标题写紧急</a></li>
<li><a href="#%E7%A4%BC%E5%A4%9A%E4%BA%BA%E4%B8%8D%E6%80%AA%E8%80%8C%E4%B8%94%E6%9C%89%E6%97%B6%E8%BF%98%E5%BE%88%E6%9C%89%E5%B8%AE%E5%8A%A9">礼多人不怪，而且有时还很有帮助</a></li>
<li><a href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%90%8E%E5%8A%A0%E4%B8%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E">问题解决后，加个简短的补充说明</a></li>
</ul>
</li>
<li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E8%AF%BB%E7%AD%94%E6%A1%88">如何解读答案</a><ul>
<li><a href="#RTFM%E5%92%8CSTFW%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E4%BD%A0%E5%B7%B2%E5%AE%8C%E5%85%A8%E6%90%9E%E7%A0%B8%E4%BA%86">RTFM和STFW：如何知道你已完全搞砸了</a></li>
<li><a href="#%E5%A6%82%E6%9E%9C%E8%BF%98%E6%98%AF%E6%90%9E%E4%B8%8D%E6%87%82">如果还是搞不懂</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%97%A0%E7%A4%BC%E7%9A%84%E5%9B%9E%E5%BA%94">处理无礼的回应</a></li>
</ul>
</li>
<li><a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%89%AE%E6%BC%94%E5%A4%B1%E8%B4%A5%E8%80%85">如何避免扮演失败者</a></li>
<li><a href="#%E4%B8%8D%E8%AF%A5%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98">不该问的问题</a></li>
<li><a href="#%E5%A5%BD%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A0%A2%E9%97%AE%E9%A2%98">好问题与蠢问题</a></li>
<li><a href="#%E5%A6%82%E6%9E%9C%E5%BE%97%E4%B8%8D%E5%88%B0%E5%9B%9E%E7%AD%94">如果得不到回答</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%9B%9E%E7%AD%94%E9%97%AE%E9%A2%98">如何更好地回答问题</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90">相关资源</a></li>
<li><a href="#%E9%B8%A3%E8%B0%A2">鸣谢</a></li>
</ul>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>许多项目在他们的使用协助/说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显着位置上注明：</p>
<p><strong>本指南不提供此项目的实际支持服务！</strong></p>
<p>我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。</p>
<p>如果你是因为需要某些协助而正在阅读这本指南，并且最后离开是因为发现从本指南作者们身上得不到直接的协助，那么你就是我们所说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而99%的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<a class="link"   href="http://www.catb.org/~esr/faqs/hacker-howto.html" >黑客<i class="fas fa-external-link-alt"></i></a>的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。</p>
<p>不只是黑客，现在开放源代码（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件**<em>好事</em>**；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。</p>
<p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发我们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，”好问题！”是诚挚的大力称赞。</p>
<p>尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。</p>
<p>我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 -– 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 <code>失败者（撸瑟）</code> （由于历史原因，我们有时把它拼作 <code>lusers</code>）。</p>
<p>我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。</p>
<p>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答<code>赢家（winner）</code>的问题。</p>
<p>如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 – 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p>
<p>所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 – 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。</p>
<p>如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 – 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p>
<p>（欢迎对本指南提出改进意见。你可以 email 你的建议至 <a href="esr@thyrsus.com">esr@thyrsus.com</a> 或 <a href="respond-auto@linuxmafia.com">respond-auto@linuxmafia.com</a>。然而请注意，本文并非<a class="link"   href="http://www.ietf.org/rfc/rfc1855.txt" >网络礼节<i class="fas fa-external-link-alt"></i></a>的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议。）</p>
<h2 id="在提问之前"><a href="#在提问之前" class="headerlink" title="在提问之前"></a>在提问之前</h2><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p>
<ol>
<li>尝试在你准备提问的论坛的旧文章中搜索答案。</li>
<li>尝试上网搜索以找到答案。</li>
<li>尝试阅读手册以找到答案。</li>
<li>尝试阅读常见问题文件（FAQ）以找到答案。</li>
<li>尝试自己检查或试验以找到答案</li>
<li>向你身边的强者朋友打听以找到答案。</li>
<li>如果你是程序开发者，请尝试阅读源代码以找到答案</li>
</ol>
<p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所**<em>学到</em>**的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p>
<p>运用某些策略，比如先用Google搜索你所遇到的各种错误信息（既搜索<a class="link"   href="http://groups.google.com/" >Google论坛<i class="fas fa-external-link-alt"></i></a>，也搜索网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 <code>我在Google中搜过下列句子但没有找到什么有用的东西</code> 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。</p>
<p>别着急，不要指望几秒钟的Google搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。</p>
<p>准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。</p>
<p>小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。</p>
<p>绝不要自以为**<em>够格</em><strong>得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去</strong><em>挣到</em>**一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 –一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。</p>
<p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p>
<h2 id="当你提问时"><a href="#当你提问时" class="headerlink" title="当你提问时"></a>当你提问时</h2><h3 id="慎选提问的论坛"><a href="#慎选提问的论坛" class="headerlink" title="慎选提问的论坛"></a>慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p>
<ul>
<li>在与主题不合的论坛上贴出你的问题</li>
<li>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然</li>
<li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）</li>
<li>向既非熟人也没有义务解决你问题的人发送私人电邮</li>
</ul>
<p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p>
<p>因此，第一步是找到对的论坛。再说一次，Google和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括<strong>阅读</strong>FAQ）都没有结果，网站上也许还有报告Bug（Bug-reporting）的流程或链接，如果是这样，连过去看看。</p>
<p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 – 如果你不确定，那就向别处发送，或者压根别发。</p>
<p>在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看FAQ或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p>
<p>别像机关枪似的一次”扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p>
<p>搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于Unix或Windows操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。</p>
<p>一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。</p>
<p>可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 – 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。</p>
<h3 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h3><p>搜索，<strong>然后</strong> 在 Stack Exchange 问。</p>
<p>近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。</p>
<p>因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。</p>
<p>Stack Exchange 已经成长到<a class="link"   href="http://stackexchange.com/sites" >超过一百个网站<i class="fas fa-external-link-alt"></i></a>，以下是最常用的几个站：</p>
<ul>
<li>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。</li>
<li>Stack Overflow 是问写程序有关的问题。</li>
<li>Server Fault 是问服务器和网管相关的问题。</li>
</ul>
<h3 id="网站和IRC论坛"><a href="#网站和IRC论坛" class="headerlink" title="网站和IRC论坛"></a>网站和IRC论坛</h3><p>本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。经过宣传的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。</p>
<p>事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用**<em>我们的</em>**版本”。</p>
<p>在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p>
<p>通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。</p>
<h3 id="第二步，使用项目邮件列表"><a href="#第二步，使用项目邮件列表" class="headerlink" title="第二步，使用项目邮件列表"></a>第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p>
<ul>
<li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。</li>
<li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li>
<li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li>
<li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li>
</ul>
<p>如果一个项目既有”使用者” 也有”开发者”（或”黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向”使用者”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。</p>
<p>然而，如果你 <strong>确信</strong> 你的问题很特别，而且在”使用者” 列表或论坛中几天都没有回复，可以试试前往”开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p>
<p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p>
<h3 id="使用有意义且描述明确的标题"><a href="#使用有意义且描述明确的标题" class="headerlink" title="使用有意义且描述明确的标题"></a>使用有意义且描述明确的标题</h3><p>在邮件列表、新闻群组或论坛中，大约50字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>（更别说<code>救命啊！！！！</code>这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而是在这点空间中使用极简单扼要的描述方式来提出问题。</p>
<p>一个好标题范例是<code>目标 -- 差异</code>式的描述，许多技术支持组织就是这样做的。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p>
<blockquote>
<p>蠢问题：救命啊！我的笔电不能正常显示了！</p>
</blockquote>
<blockquote>
<p>聪明问题：X.org 6.8.1的鼠标游标会变形，某牌显卡 MV1005 芯片组。</p>
</blockquote>
<blockquote>
<p>更聪明问题：X.org 6.8.1的鼠标游标，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p>
</blockquote>
<p>编写<code>目标 -- 差异</code> 式描述的过程有助于你组织对问题的细緻思考。是什么被影响了？ 仅仅是鼠标游标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在6.8.1版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境 <strong>和</strong> 你遇到的问题。</p>
<p>总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。</p>
<p>如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 <code>Re: 测试</code> 或者 <code>Re: 新bug</code> 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。</p>
<p>对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。</p>
<p>仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。</p>
<p>在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你 <strong>只想</strong> 在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。</p>
<h3 id="使问题容易回复"><a href="#使问题容易回复" class="headerlink" title="使问题容易回复"></a>使问题容易回复</h3><p>以<code>请将你的回复寄到……</code>来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，<a class="link"   href="http://linuxmafia.com/faq/Mail/muas.html" >换个好点的<i class="fas fa-external-link-alt"></i></a>；如果是操作系统不支持这种邮件程序，也换个好点的。</p>
<p>在论坛，要求通过电子邮件回复是非常无礼的，除非你相信回复的信息可能比较敏感（而且有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如<code>追踪此讨论串</code>、<code>有回复时发送邮件提醒</code>等功能。</p>
<h3 id="用清晰、正确、精准并语法正确的语句"><a href="#用清晰、正确、精准并语法正确的语句" class="headerlink" title="用清晰、正确、精准并语法正确的语句"></a>用清晰、正确、精准并语法正确的语句</h3><p>我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p>
<p>正确的拼字、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 – 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它 <strong>必须很</strong> 准确，而且有迹象表明你是在思考和关注问题。</p>
<p>正确地拼写、使用标点和大小写，不要将<code>its</code>混淆为<code>it&#39;s</code>，<code>loose</code>搞成<code>lose</code>或者将<code>discrete</code>弄成<code>discreet</code>。不要 <strong>全部用大写</strong> ，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。<a class="link"   href="http://en.wikipedia.org/wiki/Alan_Cox" >Alan Cox<i class="fas fa-external-link-alt"></i></a>也许可以这样做，但你不行。）</p>
<p>更白话的说，如果你写得像是个半文盲[译注：<a class="link"   href="http://zh.wikipedia.org/zh-tw/%E5%B0%8F%E7%99%BD" >小白<i class="fas fa-external-link-alt"></i></a>]），那多半得不到理睬。也不要使用即时通讯中的简写或<a class="link"   href="http://zh.wikipedia.org/zh-tw/%E7%81%AB%E6%98%9F%E6%96%87" >火星文<i class="fas fa-external-link-alt"></i></a>，如将<code>的</code>简化为<code>ㄉ</code>会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p>
<p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p>
<p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：<br>[译注：以下附上原文以供使用]</p>
<blockquote>
<p>English is not my native language; please excuse typing errors.</p>
</blockquote>
<ul>
<li>英文不是我的母语，请原谅我的错字或语法</li>
</ul>
<blockquote>
<p>If you speak $LANGUAGE, please email/PM me;<br>I may need assistance translating my question.</p>
</blockquote>
<ul>
<li>如果你说 <strong>某语言</strong> ，请寄信/私讯给我；我需要有人协助我翻译我的问题</li>
</ul>
<blockquote>
<p>I am familiar with the technical terms,<br>but some slang expressions and idioms are difficult for me.</p>
</blockquote>
<ul>
<li>我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。</li>
</ul>
<blockquote>
<p>I’ve posted my question in $LANGUAGE and English.<br>I’ll be glad to translate responses, if you only use one or the other.</p>
</blockquote>
<ul>
<li>我把我的问题用 <strong>某语言</strong> 和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。</li>
</ul>
<h3 id="使用易于读取且标准的文件格式发送问题"><a href="#使用易于读取且标准的文件格式发送问题" class="headerlink" title="使用易于读取且标准的文件格式发送问题"></a>使用易于读取且标准的文件格式发送问题</h3><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p>
<ul>
<li>使用纯文字而不是HTML (<a class="link"   href="http://archive.birdhouse.org/etc/evilmail.html" >关闭HTML<i class="fas fa-external-link-alt"></i></a>并不难）</li>
<li>使用MIME附件通常是可以的，前提是真正有内容（譬如附带的源代码或patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。</li>
<li>不要发送一段文字只是单行句子但多次断行的邮件（这使得回复部分内容非常困难）。设想你的读者是在80个字符宽的终端机上阅读邮件，最好设置你的断行点小于80字。</li>
<li>但是，也 <strong>不要</strong> 用任何固定断行资料（譬如日志档案拷贝或会话记录）。档案应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。</li>
<li>在英语论坛中，不要使用<code>Quoted-Printable</code> MIME编码发送消息。这种编码对于张贴非ASCII语言可能是必须的，但很多邮件程序并不支持这种编码。当它们分断时，那些文本中四处散布的<code>=20</code>符号既难看也分散注意力，甚至有可能破坏内容的语意。</li>
<li>绝对，<strong>永远</strong> 不要指望黑客们阅读使用封闭格式编写的文档，像是微软公司的Word或Excel文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你门口阶梯上时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li>
<li>如果你从使用Windows的电脑发送电子邮件，关闭微软愚蠢的<code>智能引号</code>功能 （从[选项] &gt; [校订] &gt; [自动校正选项], 按掉<code>智能引号</code>单选框），以免在你的邮件中到处散布垃圾字符。</li>
<li>在论坛，勿滥用 <code>表情符号</code> 和 <code>HTML</code> 功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对sex而不是有用的回复更有兴趣。</li>
</ul>
<p>如果你使用图形用户界面的邮件程序（如微软公司的Outlook或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的<code>查看源代码</code>命令，用它来检查发送文件夹中的消息，以确保发送的是没有多余杂质的纯文本文件。</p>
<h3 id="精确的描述问题并言之有物"><a href="#精确的描述问题并言之有物" class="headerlink" title="精确的描述问题并言之有物"></a>精确的描述问题并言之有物</h3><ul>
<li>仔细、清楚地描述你的问题或Bug的症状。</li>
<li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li>
<li>描述在提问前你是怎样去研究和理解这个问题的。</li>
<li>描述在提问前为确定问题而采取的诊断步骤。</li>
<li>描述最近做过什么可能相关的硬件或软件变更。</li>
<li>尽可能的提供一个可以 <code>重现这个问题的既定环境</code> 的方法</li>
</ul>
<p>尽量去揣测一个黑客会怎样反问你，在他提问的时候预先给他答案。</p>
<p>以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p>
<p><a class="link"   href="http://www.chiark.greenend.org.uk/~sgtatham/" >Simon Tatham<i class="fas fa-external-link-alt"></i></a>写过一篇名为《<a class="link"   href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-tw.html" >如何有效的报告Bug<i class="fas fa-external-link-alt"></i></a>》的出色文章。强力推荐你也读一读。</p>
<h3 id="话不在多而在精"><a href="#话不在多而在精" class="headerlink" title="话不在多而在精"></a>话不在多而在精</h3><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。</p>
<p>这样做的用处至少有三点。<br>第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；<br>第二，简化问题使你更有可能得到**<em>有用</em>**的答案；<br>第三，在精炼你的bug报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p>
<h3 id="别动辄声称找到Bug"><a href="#别动辄声称找到Bug" class="headerlink" title="别动辄声称找到Bug"></a>别动辄声称找到Bug</h3><p>当你在使用软件中遇到问题，除非你非常、<strong>非常</strong> 的有根据，不要动辄声称找到了Bug。提示：除非你能提供解决问题的源代码补丁，或者对前一版本的回归测试表现出不正确的行为，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的<code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p>
<p>请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前<a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p>
<p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。这尤其严重当你在标题中嚷嚷着有<code>Bug</code>。</p>
<p>提问时，即使你私下非常确信已经发现一个真正的Bug，最好写得像是 <strong>你</strong> 做错了什么。如果真的有Bug，你会在回复中看到这点。这样做的话，如果真有Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p>
<h3 id="可以低声下气，但还是要先做功课"><a href="#可以低声下气，但还是要先做功课" class="headerlink" title="可以低声下气，但还是要先做功课"></a>可以低声下气，但还是要先做功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 – 低声下气：<code>我知道我只是个可悲的新手，一个撸瑟(Loser)，但... </code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p>
<p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p>
<p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p>
<h3 id="描述问题症状而非猜测"><a href="#描述问题症状而非猜测" class="headerlink" title="描述问题症状而非猜测"></a>描述问题症状而非猜测</h3><p>告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p>
<p><strong>蠢问题</strong></p>
<blockquote>
<p>我在编译内核时接连遇到 SIG11 错误，<br>我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p>
</blockquote>
<p><strong>聪明问题</strong></p>
<blockquote>
<p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2芯片组），<br>256MB Corsair PC133 SDRAM内存，在编译内核时，从开机20分钟以后就频频产生 SIG11 错误，<br>但是在头20分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作20分钟。<br>所有内存都换过了，没有效果。相关部分的标准编译记录如下…。</p>
</blockquote>
<p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在1899年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！</p>
<h3 id="按发生时间先后列出问题症状"><a href="#按发生时间先后列出问题症状" class="headerlink" title="按发生时间先后列出问题症状"></a>按发生时间先后列出问题症状</h3><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如20行）记录会非常有帮助。</p>
<p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code>不等于<code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p>
<p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。</p>
<h3 id="描述目标而不是过程"><a href="#描述目标而不是过程" class="headerlink" title="描述目标而不是过程"></a>描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p>
<p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p>
<p><strong>蠢问题</strong></p>
<blockquote>
<p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的的RGB值？</p>
</blockquote>
<p><strong>聪明问题</strong></p>
<blockquote>
<p>我正试着用替换一幅图片的色码成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块，<br>但却无法从某绘图程序的颜色选择器取得十六进制的的RGB值。</p>
</blockquote>
<p>第二种提问法比较聪明，你可能得到像是<code>建议采用另一个更合适的工具</code>的回复。</p>
<h3 id="别要求使用私人电邮回复"><a href="#别要求使用私人电邮回复" class="headerlink" title="别要求使用私人电邮回复"></a>别要求使用私人电邮回复</h3><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者也能因为能力和学识被其它同行看到而得到某种奖励。</p>
<p>当你要求私下回复时，这个过程和奖励都被中止。别这样做，让 <strong><em>回复者</em></strong> 来决定是否私下回答 – 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。</p>
<p>这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是<code>向我发电邮，我将为论坛归纳这些回复</code>。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 – 但你必须信守诺言。</p>
<h3 id="清楚明确的表达你的问题以及需求"><a href="#清楚明确的表达你的问题以及需求" class="headerlink" title="清楚明确的表达你的问题以及需求"></a>清楚明确的表达你的问题以及需求</h3><p>漫无边际的提问近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p>
<p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p>
<p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p>
<p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 – 但这技巧通常和简化问题有所区别。因此，问<code>我想更好的理解X，可否指点一下哪有好一点说明？</code>通常比问<code>你能解释一下X吗？</code>更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p>
<h3 id="询问有关代码的问题时"><a href="#询问有关代码的问题时" class="headerlink" title="询问有关代码的问题时"></a>询问有关代码的问题时</h3><p>别要求他人帮你有问题的代码调试而不提示一下应该从何入手。张贴几百行的代码，然后说一声：<code>它不会动</code>会让你完全被忽略。只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;</code>比较有可能让你得到回应。</p>
<p>最有效描述程序问题的方法是提供最精简的Bug展示测试示例（bug-demonstrating test case）。什么是最精简的测试示例? 那是问题的缩影；一小个程序片段能<strong>刚好</strong>展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试示例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试示例越小越好（查看<a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a>一节）。</p>
<p>一般而言，要得到一段相当精简的测试示例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —- 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p>
<p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p>
<h3 id="别把自己家庭作业的问题贴上来"><a href="#别把自己家庭作业的问题贴上来" class="headerlink" title="别把自己家庭作业的问题贴上来"></a>别把自己家庭作业的问题贴上来</h3><p>黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由 **_你 _**来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p>
<p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的<strong>使用者</strong>邮件列表或论坛中提问。尽管黑客们 <strong><em>会</em></strong> 看出来，但一些有经验的使用者也许仍会给你一些提示。</p>
<h3 id="去掉无意义的提问句"><a href="#去掉无意义的提问句" class="headerlink" title="去掉无意义的提问句"></a>去掉无意义的提问句</h3><p>避免用无意义的话结束提问，例如<code>有人能帮我吗？</code>或者<code>这有答案吗？</code>。</p>
<p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p>
<p>其次：由于这样问是画蛇添足，黑客们会很厌烦你 – 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code>或者<code>不，没答案</code>。</p>
<p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code>类型的问句，除非你想得到<a class="link"   href="http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/questions-with-yes-or-no-answers.html" >是或否类型的回答<i class="fas fa-external-link-alt"></i></a>。</p>
<h3 id="即使你很急也不要在标题写紧急"><a href="#即使你很急也不要在标题写紧急" class="headerlink" title="即使你很急也不要在标题写紧急"></a>即使你很急也不要在标题写<code>紧急</code></h3><p>这是你的问题，不是我们的。宣称<code>紧急</code>极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，<code>紧急</code>这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 – 你希望能看到你问题的人可能永远也看不到。</p>
<p>有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。</p>
<p>当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如<code>紧急：帮我救救这个毛绒绒的小海豹！</code>肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。</p>
<p>如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。</p>
<h3 id="礼多人不怪，而且有时还很有帮助"><a href="#礼多人不怪，而且有时还很有帮助" class="headerlink" title="礼多人不怪，而且有时还很有帮助"></a>礼多人不怪，而且有时还很有帮助</h3><p>彬彬有礼，多用<code>请</code>和<code>谢谢您的关注</code>，或<code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p>
<p>坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的Bug报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教我们什么来评价问题的价值的）</p>
<p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p>
<p>（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得<code>先谢了</code>意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说<code>先谢了</code>，**<em>然后</em>** 事后再对回复者表示感谢，或者换种方式表达感激，譬如用<code>谢谢你的关注</code>或<code>谢谢你的关照</code>。）</p>
<h3 id="问题解决后，加个简短的补充说明"><a href="#问题解决后，加个简短的补充说明" class="headerlink" title="问题解决后，加个简短的补充说明"></a>问题解决后，加个简短的补充说明</h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p>
<p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含<code>已修正</code>，<code>已解决</code>或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串<code>问题 X</code>和<code>问题的X - 已解决</code>的潜在回复者就明白不用再浪费时间了（除非他个人觉得<code>问题 X</code>的有趣），因此可以利用此时间去解决其它问题。</p>
<p>补充说明不必很长或是很深入；简单的一句<code>你好，原来是网线出了问题！谢谢大家 – Bill</code>比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p>
<p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此 <strong><em>之后</em></strong> 才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p>
<p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p>
<p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p>
<p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p>
<p>在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p>
<h2 id="如何解读答案"><a href="#如何解读答案" class="headerlink" title="如何解读答案"></a>如何解读答案</h2><p><a id="RTFM"></a></p>
<h3 id="RTFM和STFW：如何知道你已完全搞砸了"><a href="#RTFM和STFW：如何知道你已完全搞砸了" class="headerlink" title="RTFM和STFW：如何知道你已完全搞砸了"></a>RTFM和STFW：如何知道你已完全搞砸了</h3><p>有一个古老而神圣的传统：如果你收到<code>RTFM （Read The Fucking Manual）</code>的回应，回答者认为你<strong>应该去读他妈的手册</strong>。当然，基本上他是对的，你应该去读一读。</p>
<p>RTFM 有一个年轻的亲戚。如果你收到<code>STFW（Search The Fucking Web）</code>的回应，回答者认为你<strong>应该到他妈的网上搜索</strong>过了。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 **<a class="link"   href="http://lmgtfy.com/" >Google是你的朋友<i class="fas fa-external-link-alt"></i></a>**！）</p>
<p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p>
<p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为</p>
<ul>
<li><strong>你需要的信息非常容易获得</strong>；</li>
<li><strong>你自己去搜索这些信息比灌给你能让你学到更多</strong>。</li>
</ul>
<p>你不应该因此不爽；<strong>依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见</strong>。你应该对他祖母般的慈祥表示感谢。</p>
<h3 id="如果还是搞不懂"><a href="#如果还是搞不懂" class="headerlink" title="如果还是搞不懂"></a>如果还是搞不懂</h3><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p>
<p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code>，然后，这是一个**<em>很糟的</em>**后续问题回应：<code>zentry是什么？</code> **<em>好</em>**的问法应该是这样：<code>哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p>
<h3 id="处理无礼的回应"><a href="#处理无礼的回应" class="headerlink" title="处理无礼的回应"></a>处理无礼的回应</h3><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p>
<p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这 <strong><em>没有</em></strong> 发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而 <strong><em>你</em></strong> 将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p>
<p>另一方面，你偶而真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p>
<p>（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会<strong>正常</strong>交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们**<em>喜欢</em>**我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑。）</p>
<p>在下一节，我们会谈到另一个问题，当**<em>你</em>**行为不当时所会受到的<code>冒犯</code>。</p>
<h2 id="如何避免扮演失败者"><a href="#如何避免扮演失败者" class="headerlink" title="如何避免扮演失败者"></a>如何避免扮演失败者</h2><p>在黑客社区的论坛中有那么几次你可能会搞砸 – 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p>
<p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做：</p>
<p>熬过去，这很正常。事实上，它是有益健康且合理的。</p>
<p>社区的标准不会自行维持，它们是通过参与者积极而 **_公开地 _**执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p>
<p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称<code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的嘮叨与无用的技术论坛。</p>
<p>夸张的讲法是：你要的是<strong>友善</strong>（以上述方式）还是有用？两个里面挑一个。</p>
<p>记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心<strong>你</strong>和<strong>他的社区</strong>而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现地有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p>
<p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是 <strong><em>真的</em></strong> 会把问题搞砸。</p>
<p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p>
<p>也别让自己卷入口水战，最好不要理睬大多数的口水战 – 当然，是在你检验它们只是口水战，而并未指出你有搞砸的地方，且也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p>
<h2 id="不该问的问题"><a href="#不该问的问题" class="headerlink" title="不该问的问题"></a>不该问的问题</h2><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p>
<p>问题：<a href="#q1">我能在哪找到 X 程序或 X 资源？</a></p>
<p>问题：<a href="#q2">我怎样用 X 做 Y？</a></p>
<p>问题：<a href="#q3">如何设定我的 shell 提示？</a></p>
<p>问题：<a href="#q4">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</a></p>
<p>问题：<a href="#q5">我的程序/设定/SQL语句没有用</a></p>
<p>问题：<a href="#q6">我的 Windows 电脑有问题，你能帮我吗？</a></p>
<p>问题：<a href="#q7">我的程序不会动了，我认为系统工具 X 有问题</a></p>
<p>问题：<a href="#q8">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p>
<p>问题：<a href="#q9">我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</a></p>
<hr>
<p><a id="q1"></a></p>
<blockquote>
<p>问题：我能在哪找到 X 程序或 X 资源？</p>
</blockquote>
<p>回答：就在我找到它的地方啊，白痴 – 搜索引擎的那一头。天哪！难道还有人不会用 <a class="link"   href="http://www.google.com/" >Google<i class="fas fa-external-link-alt"></i></a> 吗？</p>
<p><a id="q2"></a></p>
<blockquote>
<p>问题：我怎样用 X 做 Y？</p>
</blockquote>
<p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p>
<p><a id="q3"></a></p>
<blockquote>
<p>问题：如何设定我的 shell 提示？？</p>
</blockquote>
<p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="#RTFM">RTFM</a>，然后自己去找出来。</p>
<p><a id="q4"></a></p>
<blockquote>
<p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</p>
</blockquote>
<p>回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。</p>
<p><a id="q5"></a></p>
<blockquote>
<p>问题：我的程序/设定/SQL语句没有用</p>
</blockquote>
<p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 – 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p>
<ul>
<li>你还有什么要补充的吗？</li>
<li>真糟糕，希望你能搞定。</li>
<li>这关我有什么屁事？</li>
</ul>
<p><a id="q6"></a></p>
<blockquote>
<p>问题：我的 Windows 电脑有问题，你能帮我吗？</p>
</blockquote>
<p>回答：能啊，扔掉萎软的垃圾，换个像 Linux 或 BSD 的开放源代码操作系统吧。</p>
<p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如Samba），你 <strong><em>可以</em></strong> 问与Windows相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p>
<p><a id="q7"></a></p>
<blockquote>
<p>问题：我的程序不会动了，我认为系统工具 X 有问题</p>
</blockquote>
<p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p>
<p><a id="q8"></a></p>
<blockquote>
<p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p>
</blockquote>
<p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a class="link"   href="http://www.linux.org/groups/index.html" >这儿<i class="fas fa-external-link-alt"></i></a>找到使用者群组的清单）。</p>
<p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和 <strong><em>所有</em></strong> 被怀疑的硬件作关键词仔细搜索。</p>
<p><a id="q9"></a></p>
<blockquote>
<p>问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</p>
</blockquote>
<p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p>
<h2 id="好问题与蠢问题"><a href="#好问题与蠢问题" class="headerlink" title="好问题与蠢问题"></a>好问题与蠢问题</h2><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p>
<p>**<em>蠢问题</em>**：</p>
<blockquote>
<p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p>
</blockquote>
<p>这种问法无非想得到 <a href="#RTFM">STFW</a> 这样的回答。</p>
<p>**<em>聪明问题</em>**：</p>
<blockquote>
<p>我用Google搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p>
</blockquote>
<p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p>
<p><strong><em>蠢问题</em></strong></p>
<blockquote>
<p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p>
</blockquote>
<p>他觉得都是别人的错，这个傲慢自大的提问者</p>
<p><strong><em>聪明问题</em></strong></p>
<blockquote>
<p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p>
</blockquote>
<p>提问者已经指明了环境，也读过了FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p>
<p><strong><em>蠢问题</em></strong></p>
<blockquote>
<p>我的主机板有问题了，谁来帮我？</p>
</blockquote>
<p>某黑客对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p>
<p><strong><em>聪明问题</em></strong></p>
<blockquote>
<p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p>
</blockquote>
<p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p>
<p>在最后一个问题中，注意<code>告诉我答案</code>和<code>给我启示，指出我还应该做什么诊断工作</code>之间微妙而又重要的区别。</p>
<p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p>
<p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p>
<p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的**<em>名人</em>**，而是因为我用了正确的方式来提问。</p>
<p>黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我 <strong><em>像</em></strong> 个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p>
<h2 id="如果得不到回答"><a href="#如果得不到回答" class="headerlink" title="如果得不到回答"></a>如果得不到回答</h2><p>如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p>
<p>总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p>
<p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p>
<p>有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p>
<p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了– 完全可能如此 –你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p>
<p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开放源代码软件的要高得多，且内容也没那么丰富）。</p>
<h2 id="如何更好地回答问题"><a href="#如何更好地回答问题" class="headerlink" title="如何更好地回答问题"></a>如何更好地回答问题</h2><p>**<em>态度和善一点</em>**。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p>
<p>**<em>对初犯者私下回复</em>**。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p>
<p>**<em>如果你不确定，一定要说出来</em>**！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p>
<p>**<em>如果帮不了忙，也别妨碍他</em>**。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 –有些可怜的呆瓜会把它当成真的指令。</p>
<p>**<em>试探性的反问以引出更多的细节</em>**。如果你做得好，提问者可以学到点东西 –你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p>
<p>尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。</p>
<p>**<em>如果你决定回答，就请给出好的答案</em>**。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。</p>
<p>**<em>正面的回答问题</em>**！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p>
<p>**<em>帮助你的社区从问题中学习</em>**。当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p>
<p>如果你是在研究一番后才做出的回答，**<em>展现你的技巧而不是直接端出结果</em>**。毕竟<code>授人以鱼不如授人以渔</code>。</p>
<h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><p>如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅<a class="link"   href="http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/" >Unix系统和网络基本原理<i class="fas fa-external-link-alt"></i></a>。</p>
<p>当你发布软件或补丁时，试着按<a class="link"   href="http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html" >软件发布实践<i class="fas fa-external-link-alt"></i></a>操作。</p>
<h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>Evelyn Mitchel贡献了一些愚蠢问题例子并启发了编写<code>如何更好地回答问题</code>这一节， Mikhail Ramendik贡献了一些特别有价值的建议和改进。</p>
]]></content>
  </entry>
</search>
